<!doctype html>
<html class="docs-version-current" lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.15">
<title data-react-helmet="true">概述 | 你好 Compose</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:url" content="https://jetpackcompose.cn/docs/design/animation/overview"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="概述 | 你好 Compose"><meta data-react-helmet="true" name="description" content="Jetpack Compose 提供了强大的、可扩展的 API，使得在你的应用程序的用户界面上实现各种动画变得更容易。本文描述了如何使用这些 API，以及根据你的动画场景使用哪个 API。"><meta data-react-helmet="true" property="og:description" content="Jetpack Compose 提供了强大的、可扩展的 API，使得在你的应用程序的用户界面上实现各种动画变得更容易。本文描述了如何使用这些 API，以及根据你的动画场景使用哪个 API。"><link data-react-helmet="true" rel="icon" href="/img/logo.svg"><link data-react-helmet="true" rel="canonical" href="https://jetpackcompose.cn/docs/design/animation/overview"><link data-react-helmet="true" rel="alternate" href="https://jetpackcompose.cn/docs/design/animation/overview" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://jetpackcompose.cn/docs/design/animation/overview" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.cba56bc1.css">
<link rel="preload" href="/assets/js/runtime~main.003b15d9.js" as="script">
<link rel="preload" href="/assets/js/main.3ccbd39c.js" as="script">
</head>
<body data-theme="light">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region"><a href="#" class="skipToContent_ZgBM">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_W2Cr themedImage--light_TfLj"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_W2Cr themedImage--dark_oUvU"></div><b class="navbar__title">Jetpack Compose 博物馆</b></a><a class="navbar__item navbar__link navbar__link--active" href="/docs/">文档</a><a class="navbar__item navbar__link" href="/docs/open-source-project/compose-douban">开源项目</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/milklabdev/jetpack-compose-book" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><div class="toggle_Pssr toggle_TdHA toggleDisabled_jDku"><div class="toggleTrack_SSoT" role="button" tabindex="-1"><div class="toggleTrackCheck_XobZ"><span class="toggleIcon_eZtF">🌜</span></div><div class="toggleTrackX_YkSC"><span class="toggleIcon_eZtF">🌞</span></div><div class="toggleTrackThumb_uRm4"></div></div><input type="checkbox" class="toggleScreenReader_JnkT" aria-label="Switch between dark and light mode"></div><div class="dsla-search-wrapper"><div class="dsla-search-field" data-tags="default,docs-default-current"></div></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docs-wrapper docs-doc-page"><div class="docPage_P2Lg"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_RiI4" type="button"></button><aside class="theme-doc-sidebar-container docSidebarContainer_rKC_"><div class="sidebar_CW9Y"><nav class="menu thin-scrollbar menu_SkdO"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/">写在开头</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link hasHref_VCh3" href="/docs/category/入门">入门</a><button aria-label="Toggle the collapsible sidebar category &#x27;入门&#x27;" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/installation">安装或更新 Android Studio</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/tutorial">初识 Jetpack Compose</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" href="/docs/elements/alertdialog">基础组件</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" href="/docs/layout/box">布局组件</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--active hasHref_VCh3" aria-current="page" href="/docs/category/设计">设计</a><button aria-label="Toggle the collapsible sidebar category &#x27;设计&#x27;" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--active hasHref_VCh3" aria-current="page" tabindex="0" href="/docs/category/动画animation">动画（Animation）</a><button aria-label="Toggle the collapsible sidebar category &#x27;动画（Animation）&#x27;" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/design/animation/overview">概述</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/design/animation/animationVisibility">AnimationVisibility（实验性）</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/design/animation/animateAsState">Animate*AsState</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/design/animation/animatable">Animatable</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/design/animation/updateTransition">UpdateTranstion</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link hasHref_VCh3" tabindex="0" href="/docs/category/主题theming">主题（Theming）</a><button aria-label="Toggle the collapsible sidebar category &#x27;主题（Theming）&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link hasHref_VCh3" tabindex="0" href="/docs/category/手势gesture">手势（Gesture）</a><button aria-label="Toggle the collapsible sidebar category &#x27;手势（Gesture）&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link hasHref_VCh3" tabindex="0" href="/docs/category/列表lists">列表（Lists）</a><button aria-label="Toggle the collapsible sidebar category &#x27;列表（Lists）&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link hasHref_VCh3" tabindex="0" href="/docs/category/图形graphics">图形（Graphics）</a><button aria-label="Toggle the collapsible sidebar category &#x27;图形（Graphics）&#x27;" type="button" class="clean-btn menu__caret"></button></div></li></ul></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/resources">资源</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link hasHref_VCh3" href="/docs/category/技术原理">技术原理</a><button aria-label="Toggle the collapsible sidebar category &#x27;技术原理&#x27;" type="button" class="clean-btn menu__caret"></button></div></li></ul></nav></div></aside><main class="docMainContainer_TCnq"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_DM6M"><div class="docItemContainer_vinB"><article><div class="tocCollapsible_jdIR theme-doc-toc-mobile tocMobile_TmEX"><button type="button" class="clean-btn tocCollapsibleButton_Fzxq">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>概述</h1></header><p>Jetpack Compose 提供了强大的、可扩展的 API，使得在你的应用程序的用户界面上实现各种动画变得更容易。本文描述了如何使用这些 API，以及根据你的动画场景使用哪个 API。</p><p>动画在现代移动应用中至关重要，其目的是实现自然流畅、易于理解的用户体验。许多 Jetpack Compose 动画 API 可以提供可组合函数，就像布局和其他界面元素一样；它们由使用 Kotlin 协程挂起函数构建的较低级别 API 提供支持。本指南将首先介绍可用于许多实际场景的高级别 API，接着介绍可为您提供进一步控制和自定义功能的低级别 API。</p><p>下面的图表可以帮助您确定要使用哪种 API 来实现您的动画效果。</p><img src="/assets/images/demo-1fe6a47b026d0b639fa7ea62cf3669ba.png"><ul><li><p>如果您要为布局中的内容变化添加动画效果：</p><ul><li><p>如果您要为进入/退出过渡添加动画效果：</p><ul><li>使用 <code>AnimationVisibility</code>。</li></ul></li><li><p>如果您要为内容大小变化添加动画效果：</p><ul><li>使用 <code>Modifier.animateContentSize</code>。</li></ul></li><li><p>否则使用 <code>Crossfade</code>。</p></li></ul></li><li><p>如果动画效果基于状态：</p><ul><li>如果在组合期间呈现动画效果：<ul><li>如果动画效果无限循环：<ul><li>使用 <code>rememberInfiniteTransition</code>。</li></ul></li></ul></li></ul></li><li><p>如果您要同时为多个值添加动画效果：</p><ul><li>使用 <code>updateTransition</code>。</li><li>否则使用 <code>animate*AsState</code>。</li></ul></li><li><p>如果您要对动画播放时间进行精细控制：</p><ul><li>使用 <code>Animation</code>。</li></ul></li><li><p>如果动画是唯一可信来源：</p><ul><li>使用 <code>Animatable</code>。</li><li>否则，请使用 <code>AnimationState</code> 或 <code>animate</code>。</li></ul></li></ul><table><thead><tr><th>API</th><th>功能</th></tr></thead><tbody><tr><td><strong><a href="/docs/design/animation/animationvisibility">AnimationVisibility</a></strong></td><td><strong>显示/隐藏的过渡动画</strong></td></tr><tr><td><strong>Modifier.contentSize</strong></td><td><strong>内容大小的变化过渡动画</strong></td></tr><tr><td><strong>Crossfade</strong></td><td></td></tr><tr><td><strong>rememberInfiniteTransition</strong></td><td></td></tr><tr><td><strong><a href="/docs/design/animation/updateTransition">updateTransition</a></strong></td><td><strong>实现过渡动画的关键 API</strong></td></tr><tr><td><strong><a href="/docs/design/animation/animateAsState">animate*AsState</a></strong></td><td><strong>指定类型的数据变化动画</strong></td></tr></tbody></table><h2 class="anchor anchorWithStickyNavbar_mojV" id="2-高级动画-api">2. 高级动画 API<a class="hash-link" href="#2-高级动画-api" title="Direct link to heading">​</a></h2><p><code>Compose</code> 为许多应用程序中使用的几种常见动画模式提供了高级动画 <code>API</code>。 这些 <code>API</code> 是为适应 <a href="https://material.io/design/motion/" target="_blank" rel="noopener noreferrer">Material Design Motion</a> 而量身定制的。</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="animatedvisibiliy-实验性">AnimatedVisibiliy (实验性)<a class="hash-link" href="#animatedvisibiliy-实验性" title="Direct link to heading">​</a></h3><div class="admonition admonition-warning alert alert--danger"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="16" viewBox="0 0 12 16"><path fill-rule="evenodd" d="M5.05.31c.81 2.17.41 3.38-.52 4.31C3.55 5.67 1.98 6.45.9 7.98c-1.45 2.05-1.7 6.53 3.53 7.7-2.2-1.16-2.67-4.52-.3-6.61-.61 2.03.53 3.33 1.94 2.86 1.39-.47 2.3.53 2.27 1.67-.02.78-.31 1.44-1.13 1.81 3.42-.59 4.78-3.42 4.78-5.56 0-2.84-2.53-3.22-1.25-5.61-1.52.13-2.03 1.13-1.89 2.75.09 1.08-1.02 1.8-1.86 1.33-.67-.41-.66-1.19-.06-1.78C8.18 5.31 8.68 2.45 5.05.32L5.03.3l.02.01z"></path></svg></span>注意</h5></div><div class="admonition-content"><p>实验性API将来可能会更改，或者可能会完全删除。</p></div></div><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 如果你在这里有 getValue 的报错，或者无法自动导入，这是一些旧版 Android Studio 还没有完全适配 Compose 的 bug。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 你需要手动导入，或者更新到最新的 AS</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// import androidx.compose.runtime.getValue</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">var state by remember{ mutableStateOf(true) }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Column(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    modifier = Modifier</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .fillMaxSize(),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    horizontalAlignment = Alignment.CenterHorizontally,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    verticalArrangement = Arrangement.Center</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    AnimatedVisibility(visible = state) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Text(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            text = &quot;这是一个普通的正文&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            fontWeight = FontWeight.W900,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            style = MaterialTheme.typography.h5</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Spacer(Modifier.padding(vertical = 50.dp))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Button(onClick = {state = !state}) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Text(if(state) &quot;隐藏&quot; else &quot;显示&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>默认情况下</p><p>内容通过 <code>fadeIn()</code> 和 <code>expandVertically()</code> 出现</p><p>通过 <code>fadeOut()</code> 和 <code>shrinkVertically()</code> 消失。你可以通过指定 <code>EnterTransition</code> 和 <code>ExitTransition</code> 来自定义过渡效果。</p><img src="/assets/images/demo-28e07a821bd06d02f1c9700ed0215d7f.gif"><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">var state by remember{ mutableStateOf(true) }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Column(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    modifier = Modifier</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .fillMaxSize(),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    horizontalAlignment = Alignment.CenterHorizontally,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    verticalArrangement = Arrangement.Center</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    AnimatedVisibility(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        visible = state,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        enter = slideInVertically(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            initialOffsetY = { -40 }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ) + expandVertically(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            expandFrom = Alignment.Top</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ) + fadeIn(initialAlpha = 0.3f),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        exit = shrinkHorizontally() + fadeOut()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Text(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            text = &quot;这是一个普通的正文&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            fontWeight = FontWeight.W900,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            style = MaterialTheme.typography.h5</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Spacer(Modifier.padding(vertical = 50.dp))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Button(onClick = { state = !state }) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Text(if (state) &quot;隐藏&quot; else &quot;显示&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><img src="/assets/images/demo10-bcfc91c79b09a6054d6dca3d7dd38d3c.gif"><p>如上例所示，你可以将多个 <code>EnterTransition</code> 或 <code>ExitTransition</code> 对象与一个 <code>+</code> 运算符组合在一起，并且每个对象都接受可选参数以自定义其行为。</p><p><code>EnterTransition</code> 的一些方法</p><p><a href="https://developer.android.com/reference/kotlin/androidx/compose/animation/package-summary#fadeIn(kotlin.Float,androidx.compose.animation.core.FiniteAnimationSpec)" target="_blank" rel="noopener noreferrer"><code>fadeIn</code></a></p><img src="https://developer.android.com/images/jetpack/compose/animation-fadein.gif" width="100" height="100"><p><a href="https://developer.android.com/reference/kotlin/androidx/compose/animation/package-summary#slideIn(kotlin.Function1,androidx.compose.animation.core.FiniteAnimationSpec)" target="_blank" rel="noopener noreferrer"><code>slideIn</code></a></p><img src="https://developer.android.com/images/jetpack/compose/animation-slidein.gif" width="100" height="100"><p><a href="https://developer.android.com/reference/kotlin/androidx/compose/animation/package-summary#expandIn(androidx.compose.ui.Alignment,kotlin.Function1,androidx.compose.animation.core.FiniteAnimationSpec,kotlin.Boolean)" target="_blank" rel="noopener noreferrer"><code>expandIn</code></a></p><img src="https://developer.android.com/images/jetpack/compose/animation-expandin.gif" width="100" height="100"><p><a href="https://developer.android.com/reference/kotlin/androidx/compose/animation/package-summary#expandHorizontally(androidx.compose.ui.Alignment.Horizontal,kotlin.Function1,androidx.compose.animation.core.FiniteAnimationSpec,kotlin.Boolean)" target="_blank" rel="noopener noreferrer"><code>expandHorizontally</code></a></p><img src="https://developer.android.com/images/jetpack/compose/animation-expandhorizontally.gif" width="100" height="100"><p><a href="https://developer.android.com/reference/kotlin/androidx/compose/animation/package-summary#expandVertically(androidx.compose.ui.Alignment.Vertical,kotlin.Function1,androidx.compose.animation.core.FiniteAnimationSpec,kotlin.Boolean)" target="_blank" rel="noopener noreferrer"><code>expandVertically</code></a></p><img src="https://developer.android.com/images/jetpack/compose/animation-expandvertically.gif" width="100" height="100"><p><a href="https://developer.android.com/reference/kotlin/androidx/compose/animation/package-summary#slideInHorizontally(kotlin.Function1,androidx.compose.animation.core.FiniteAnimationSpec)" target="_blank" rel="noopener noreferrer"><code>slideInHorizontally</code></a></p><img src="https://developer.android.com/images/jetpack/compose/animation-slideinhorizontally.gif" width="100" height="100"><p><a href="https://developer.android.com/reference/kotlin/androidx/compose/animation/package-summary#slideInVertically(kotlin.Function1,androidx.compose.animation.core.FiniteAnimationSpec)" target="_blank" rel="noopener noreferrer"><code>slideInVertically</code></a></p><img src="https://developer.android.com/images/jetpack/compose/animation-slideinvertically.gif" width="100" height="100"><p><code>ExitTransition</code> 的一些方法</p><p><a href="https://developer.android.com/reference/kotlin/androidx/compose/animation/package-summary#fadeOut(kotlin.Float,androidx.compose.animation.core.FiniteAnimationSpec)" target="_blank" rel="noopener noreferrer"><code>fadeOut</code></a></p><img src="https://developer.android.com/images/jetpack/compose/animation-fadeout.gif" width="100" height="100"><p><a href="https://developer.android.com/reference/kotlin/androidx/compose/animation/package-summary#slideOut(kotlin.Function1,androidx.compose.animation.core.FiniteAnimationSpec)" target="_blank" rel="noopener noreferrer"><code>slideOut</code></a></p><img src="https://developer.android.com/images/jetpack/compose/animation-slideout.gif" width="100" height="100"><p><a href="https://developer.android.com/reference/kotlin/androidx/compose/animation/package-summary#shrinkOut(androidx.compose.ui.Alignment,kotlin.Function1,androidx.compose.animation.core.FiniteAnimationSpec,kotlin.Boolean)" target="_blank" rel="noopener noreferrer"><code>shrinkOut</code></a></p><img src="https://developer.android.com/images/jetpack/compose/animation-shrinkout.gif" width="100" height="100"><p><a href="https://developer.android.com/reference/kotlin/androidx/compose/animation/package-summary#shrinkHorizontally(androidx.compose.ui.Alignment.Horizontal,kotlin.Function1,androidx.compose.animation.core.FiniteAnimationSpec,kotlin.Boolean)" target="_blank" rel="noopener noreferrer"><code>shrinkHorizontally</code></a></p><img src="https://developer.android.com/images/jetpack/compose/animation-shrinkhorizontally.gif" width="100" height="100"><p><a href="https://developer.android.com/reference/kotlin/androidx/compose/animation/package-summary#shrinkVertically(androidx.compose.ui.Alignment.Vertical,kotlin.Function1,androidx.compose.animation.core.FiniteAnimationSpec,kotlin.Boolean)" target="_blank" rel="noopener noreferrer"><code>shrinkVertically</code></a></p><img src="https://developer.android.com/images/jetpack/compose/animation-shrinkvertically.gif" width="100" height="100"><p><a href="https://developer.android.com/reference/kotlin/androidx/compose/animation/package-summary#shrinkHorizontally(androidx.compose.ui.Alignment.Horizontal,kotlin.Function1,androidx.compose.animation.core.FiniteAnimationSpec,kotlin.Boolean)" target="_blank" rel="noopener noreferrer"><code>slideOutHorizontally</code></a></p><img src="https://developer.android.com/images/jetpack/compose/animation-slideouthorizontally.gif" width="100" height="100"><p><a href="https://developer.android.com/reference/kotlin/androidx/compose/animation/package-summary#slideOutVertically(kotlin.Function1,androidx.compose.animation.core.FiniteAnimationSpec)" target="_blank" rel="noopener noreferrer"><code>slideOutVertically</code></a></p><img src="https://developer.android.com/images/jetpack/compose/animation-slideoutvertically.gif" width="100" height="100"><h3 class="anchor anchorWithStickyNavbar_mojV" id="animatecontentsize">animateContentSize<a class="hash-link" href="#animatecontentsize" title="Direct link to heading">​</a></h3><p><code>animateContentSize</code> 可以对尺寸更改进行动画处理</p><p>以下是一个简单的例子：</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">var text by remember{ mutableStateOf(&quot;animateContentSize 动画&quot;) }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Box(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    modifier = Modifier.fillMaxSize(),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    contentAlignment = Alignment.Center</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Text(text, modifier = Modifier</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .clickable{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            text += text</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .animateContentSize()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><img src="/assets/images/demo-28e07a821bd06d02f1c9700ed0215d7f.gif"><p>再来看看没有加 <code>animateContentSize()</code> 的效果吧</p><img src="/assets/images/demo2-a8f66207f656f0590f2f0a0162536860.gif"><h3 class="anchor anchorWithStickyNavbar_mojV" id="crossfade">Crossfade<a class="hash-link" href="#crossfade" title="Direct link to heading">​</a></h3><p><code>Crossfade</code> 在两个布局之间用交叉淡入淡出的动画。通过切换传递给当前参数的值，内容以交叉渐变动画的方式切换</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">@Composable</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fun &lt;T&gt; Crossfade(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    targetState: T,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    modifier: Modifier = Modifier,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    animationSpec: FiniteAnimationSpec&lt;Float&gt; = tween(),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    content: @Composable (T) -&gt; Unit</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>来看看一个简单的使用</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">var flag by remember{ mutableStateOf(false) }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Column{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Crossfade(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         targetState = flag, animationSpec = tween(1000)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        when(it){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            false -&gt; Screen1()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            true -&gt; Screen2()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Button(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         onClick = { flag = !flag }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Text(&quot;切换&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Composable</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fun Screen1() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Box(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        modifier = Modifier</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            .background(Color.Red)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            .size(200.dp),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        contentAlignment = Alignment.Center</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ) { }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Composable</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fun Screen2() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Box(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        modifier = Modifier</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            .background(Color.Blue)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            .size(200.dp),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        contentAlignment = Alignment.Center</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ) { }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><img src="/assets/images/demo3-8792a2235904337fb6eab6657b5fddd3.gif"><h2 class="anchor anchorWithStickyNavbar_mojV" id="3-低级动画-api">3. 低级动画 API<a class="hash-link" href="#3-低级动画-api" title="Direct link to heading">​</a></h2><p>上一节提到的所有高级动画 <code>API</code> 都是建立在低级动画 <code>API</code> 的基础之上的。</p><p><code>animate*AsState</code> 函数是最简单的 <code>API</code>，它将一个即时的值变化渲染成一个动画值。它由 <code>Animatable</code> 支持，<code>Animatable</code> 是一个基于协程的 <code>API</code>，用于给单个值制作动画。<code>updateTransition</code> 创建了一个过渡对象，可以管理多个动画值，并根据状态变化运行它们。<code>rememberInfiniteTransition</code> 类似，但它创建了一个无限的过渡，可以管理多个动画，无限地持续运行。除了 <code>Animatable</code> 之外，所有这些<code>API</code> 都是可组合的，这意味着可以在合成之外创建这些动画。</p><p>所有这些 <code>API</code> 都是基于更基本的 <code>Animation API</code>。尽管大多数应用程序不会直接与 <code>Animation</code> 交互，但 <code>Animation</code> 的一些定制功能可以通过更高级别的 <code>API</code> 获得。关于 <code>AnimationVector</code> 和 <code>AnimationSpec</code> 的更多信息，请参阅<a href="/docs/design/animation/overview#4-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8A%A8%E7%94%BB">自定义动画</a>。</p><img><h3 class="anchor anchorWithStickyNavbar_mojV" id="animateasstate">animate*AsState<a class="hash-link" href="#animateasstate" title="Direct link to heading">​</a></h3><p><code>animate*AsState</code> 函数是 <code>Compose</code> 中最简单的动画 <code>API</code>，用于为单个值制作动画。你只需提供结束值（或目标值），<code>API</code> 就会从当前值到指定值开始动画。</p><p>下面是一个使用这个 <code>API</code> 制作 <code>alpha</code> 动画的例子。通过简单地将目标值包裹在 <code>animateFloatAsState</code> 中，<code>alpha</code> 值现在是一个介于所提供的值（本例中是 <code>1f</code> 或 <code>0.5f</code>）之间的动画值。</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">val alpha: Float by animateFloatAsState(if (enabled) 1f else 0.5f)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Box(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Modifier.fillMaxSize()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .graphicsLayer(alpha = alpha)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .background(Color.Red)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>在这里查看关于 <a href="/docs/design/animation/animateAsState"><code>animate*AsState</code></a> 的更多介绍</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="animatable">Animatable<a class="hash-link" href="#animatable" title="Direct link to heading">​</a></h3><p><code>Animatable</code> 会在内部储存一个值，当值通过 <code>animateTo</code> 被改变时，它可以产生动画。这就是支持 <code>animate*AsState</code> 实现的 <code>API</code>。它确保了一致的延续性和互斥性，这意味着值的变化总是连续的，任何正在进行的动画都会被取消。</p><p><code>Animatable</code> 的许多功能，包括 <code>animateTo</code>，都是作为 <code>suspend</code> 函数提供的。这意味着它们需要被包裹在一个适当的协程作用域内内。例如，你可以使用 <code>LaunchedEffect</code> 这个 <strong>Composable</strong> 来创建一个只针对指定键值的持续时间的作用域。</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">var flag by remember{ mutableStateOf(false) }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">val color = remember{ Animatable(Color.Gray) }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Column{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Box(Modifier.size(300.dp).background(color.value))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Button(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         onClick = { flag = !flag }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Text(&quot;切换&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">LaunchedEffect(flag) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    color.animateTo(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        targetValue = if (flag){ Color.Green } else { Color.Red },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        animationSpec = tween(1000)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><img src="/assets/images/demo4-8c1d4d1d7b5ded27836c59539133e1a3.gif"><p>在上面的例子中，我们创建并记住了一个 <code>Animatable</code> 的实例，其初始值为 <code>Color.Gray</code>。根据 <code>flag</code> 的值，颜色会动画地变成 <code>Color.Green</code> 或 <code>Color.Red</code>。任何对 <code>flag</code> 的后续改变都会启动动画到另一种颜色。如果在改变值的时候有一个正在进行的动画，那么这个动画会被取消，新的动画会从当前的快照值和当前的速度开始。</p><p>这是支持上一节中提到的 <code>animate*AsState</code> <code>API</code> 的动画实现。与 <code>animate*AsState</code> 相比，直接使用 <code>Animatable</code> 在几个方面给了我们更精细的控制。首先，<code>Animatable</code> 可以有一个不同于其第一个目标值的初始值。例如，上面的代码例子一开始显示的是一个灰色的盒子，当运行程序的时候立即开始动画地变成为绿色或红色。第二，<code>Animatable</code> 对内容值提供了更多的操作，即 <code>snapTo</code> 和 <code>animateDecay</code>。 <code>snapTo</code> 将当前值立即设置为目标值。当动画本身不是唯一的数据源，并且必须与其他状态同步时，例如触摸事件，这是非常有用的。 <code>animateDecay</code> 启动一个从给定速度开始放缓的动画。这对于实现甩动行为很有用。更多信息见手势和动画。</p><p><code>Animatable</code> 支持 <code>Float</code> 和 <code>Color</code>，但任何数据类型都可以通过提供一个 <code>TwoWayConverter</code> 来使用。参见 AnimationVector 获取更多信息。</p><p>你可以通过提供一个 <code>AnimationSpec</code> 来定制动画规格。参见 AnimationSpec 获取更多信息。</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="updatetransition">updateTransition<a class="hash-link" href="#updatetransition" title="Direct link to heading">​</a></h3><p><code>Transition</code> 管理一个或多个动画作为它的子项，并在多个状态之间同时运行它们。</p><p>这些状态可以是任何数据类型。在许多情况下，你可以使用一个自定义的枚举类型来确保类型安全，就像这个例子中一样。</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">private enum class BoxState {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Collapsed,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Expanded</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p><code>updateTransition</code> 可以创建并记住一个 <code>Transition</code> 的实例并更新其状态</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">var currentState by remember { mutableStateOf(BoxState.Collapsed) }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">val transition = updateTransition(currentState)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>然后你可以使用 <code>animate*</code> 扩展函数中的一个在这个过渡中定义一个子动画。指定每个状态的目标值。这些 <code>animate*</code> 函数返回一个动画值，在动画过程中，当用 <code>updateTransition</code> 更新过渡状态时，每一帧都会更新。</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">var currentState by remember { mutableStateOf(BoxState.Collapsed) }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">val transition = updateTransition(currentState)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">val rect by transition.animateDp { state -&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    when (state) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        BoxState.Collapsed -&gt; 0.dp</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        BoxState.Expanded -&gt; 150.dp</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Box(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    modifier = Modifier</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .size(rect)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .background(Color(0xFF0079D3)),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">) { }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    </span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><img src="/assets/images/demo5-ccfa373a2ffc1f3eafc74ab48a9c9436.gif"><p>你可以选择传递一个 <code>transitionSpec</code> 参数，为每个过渡状态变化的组合指定一个不同的 <code>AnimationSpec</code>。参见 <a href="https://developer.android.com/jetpack/compose/animation#animationspec" target="_blank" rel="noopener noreferrer">AnimationSpec</a> 以了解更多信息。</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">val rect by transition.animateDp(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    transitionSpec = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        when {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            BoxState.Expanded isTransitioningTo BoxState.Collapsed -&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                spring(stiffness = 50f)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            else -&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                tween(durationMillis = 500) // 动画时间</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">){ state -&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    when (state) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        BoxState.Collapsed -&gt; 0.dp</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        BoxState.Expanded -&gt; 150.dp</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><img src="/assets/images/demo6-5d4343178be7e057c40ef43febd92277.gif"><p>一旦一个 <code>transition</code> 到达目标状态，<code>Transition.currentState</code> 将与 <code>Transition.targetState</code> 相同。这可以作为过渡是否完成的一个信号。</p><p>我们有时希望有一个与第一个目标状态不同的初始状态。我们可以使用 <code>updateTransition</code> 与 <code>MutableTransitionState</code> 来实现这一点。例如，它允许我们在代码进入合成时立即开始动画。</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">var currentState = remember { MutableTransitionState(BoxState.Collapsed) }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 在运行程序时，将 currentState 的值变为 BoxState.Expanded，也就意味着，将会直接运行动画</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">currentState.targetState = BoxState.Expanded</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">val transition = updateTransition(currentState)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p><strong>封装一个 Transition 并让它可以重复使用</strong></p><p>对于简单的用例，在与你的用户界面相同的 <code>composable</code> 中定义过渡动画是一个完全有效的选择。然而，当你正在处理一个有许多动画值的复杂组件时，你可能想把动画实现与可组合的用户界面分开。</p><p>你可以通过创建一个持有所有动画值的类和一个返回该类实例的 &quot;更新 &quot;函数来做到这一点。过渡的实现可以被提取到新的独立函数中。当需要集中动画逻辑或使复杂的动画可重复使用时，这种模式很有用。</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">enum class BoxState { Collapsed, Expanded }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Composable</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fun AnimatingBox(boxState: BoxState) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    val transitionData = updateTransitionData(boxState)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // UI 树</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Box(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        modifier = Modifier</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            .background(transitionData.color)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            .size(transitionData.size)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 保存动画数值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private class TransitionData(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    color: State&lt;Color&gt;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    size: State&lt;Dp&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    val color by color</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    val size by size</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 创建一个 Transition 并返回其动画值。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Composable</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private fun updateTransitionData(boxState: BoxState): TransitionData {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    val transition = updateTransition(boxState)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    val color = transition.animateColor { state -&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        when (state) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            BoxState.Collapsed -&gt; Color.Gray</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            BoxState.Expanded -&gt; Color.Red</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    val size = transition.animateDp { state -&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        when (state) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            BoxState.Collapsed -&gt; 64.dp</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            BoxState.Expanded -&gt; 128.dp</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return remember(transition) { TransitionData(color, size) }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_mojV" id="rememberinfinitetransition">rememberInfiniteTransition<a class="hash-link" href="#rememberinfinitetransition" title="Direct link to heading">​</a></h3><p><code>InfiniteTransition</code> 像 <code>Transition</code> 一样持有一个或多个子动画，但这些动画一进入构图就开始运行，除非它们被移除，否则不会停止。你可以用 <code>rememberInfiniteTransition</code> 创建一个 <code>InfiniteTransition</code> 的实例。子动画可以用 <code>animateColor</code>、<code>animatedFloat</code> 或 <code>animatedValue</code> 添加。你还需要指定一个 <code>infiniteRepeatable</code> 来指定动画形式。</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">val infiniteTransition = rememberInfiniteTransition()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">val color by infiniteTransition.animateColor(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    initialValue = Color.Red, // 初始值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    targetValue = Color.Green, // 最终值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    animationSpec = infiniteRepeatable(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        animation = tween(1000, easing = LinearEasing), // 一个动画值的转换持续 1 秒，缓和方式为 LinearEasing</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        repeatMode = RepeatMode.Reverse </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 指定动画重复运行的方式，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Reverse 为 init -&gt; target, target -&gt; init, init -&gt; target</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Repeat 为 init -&gt; target, init -&gt; target, init -&gt; target</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Box(Modifier.fillMaxSize().background(color))</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><img src="/assets/images/demo7-3176fcf970b60feee96841c60a14b9a9.gif"><h3 class="anchor anchorWithStickyNavbar_mojV" id="targetbasedanimation">TargetBasedAnimation<a class="hash-link" href="#targetbasedanimation" title="Direct link to heading">​</a></h3><p><code>TargetBasedAnimation</code> 是我们到目前为止看到的最低级别的动画 <code>API</code>。其他 <code>API</code> 涵盖了大多数的使用情况，但直接使用 <code>TargetBasedAnimation</code> 可以让你自己控制动画的播放时间。在下面的例子中，<code>TargetAnimation</code> 的播放时间是根据 <code>withFrameMillis</code> 提供的帧时间手动控制的。</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">val anim = remember {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    TargetBasedAnimation(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        animationSpec = tween(200),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        typeConverter = Float.VectorConverter,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        initialValue = 200f,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        targetValue = 1000f</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">var playTime by remember { mutableStateOf(0L) }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">LaunchedEffect(anim) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    val startTime = withFrameNanos { it }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    do {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        playTime = withFrameNanos { it } - startTime</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        val animationValue = anim.getValueFromNanos(playTime)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } while (someCustomCondition())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h2 class="anchor anchorWithStickyNavbar_mojV" id="4-自定义动画">4. 自定义动画<a class="hash-link" href="#4-自定义动画" title="Direct link to heading">​</a></h2><p>许多动画 <code>API</code> 通常接受参数来定制它的行为。</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="animationspec">AnimationSpec<a class="hash-link" href="#animationspec" title="Direct link to heading">​</a></h3><p>大多数动画 <code>API</code> 允许开发者通过一个可选的 <code>AnimationSpec</code> 参数来定制动画规格。</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">val alpha: Float by animateFloatAsState(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    targetValue = if (enabled) 1f else 0.5f,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 配置动画的持续时间和缓和度</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    animationSpec = tween(durationMillis = 300, easing = FastOutSlowInEasing)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>有不同种类的 <code>AnimationSpec</code> 用于创建不同类型的动画。</p><p><strong>spring</strong></p><p><code>spring</code> 在起始值和结束值之间创建一个基于物理学的动画。它需要 <code>2</code> 个参数：阻尼率和刚度。</p><p><code>dampingRatio</code> 定义了弹簧的反弹程度。默认值是 <code>Spring.DampingRatioNoBouncy</code>。</p><img src="/assets/images/animation-spring-c372b0c453dc981aac1380574fb0196f.gif"><p><code>stiffness</code> 定义了弹簧向最终值移动的速度。默认值是 <code>Spring.StiffnessMedium</code>。</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">val value by animateFloatAsState(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    targetValue = 1f,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    animationSpec = spring(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        dampingRatio = Spring.DampingRatioHighBouncy,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        stiffness = Spring.StiffnessMedium</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p><code>spring</code> 可以比基于持续时间的 <code>AnimationSpec</code> 类型更顺利地处理中断，因为它保证了目标值在动画中变化时速度的连续性。 <code>spring</code> 被许多动画 <code>API</code> 用作默认的 <code>AnimationSpec</code>，如 <code>animate*AsState</code> 和 <code>updateTransition</code> 。</p><p><strong>tween</strong></p><p><code>tween</code> 在指定的 <code>durationMillis</code> 上使用缓和曲线在开始和结束值之间进行动画。更多信息请看 <a href="https://developer.android.com/jetpack/compose/animation#easing" target="_blank" rel="noopener noreferrer">Easing</a>。你也可以指定 <code>delayMillis</code> 来推迟动画的开始时间。</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">val value by animateFloatAsState(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    targetValue = 1f,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    animationSpec = tween(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        durationMillis = 300,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        delayMillis = 50,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        easing = LinearOutSlowInEasing</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p><strong>keyframes</strong></p><p><code>keyframes</code> 的动画基于动画持续时间中不同时间戳指定的快照值。在任何时候，动画值将在两个 <code>keyframes</code> 值之间插值。对于这些 <code>keyframes</code> 中的每一个，可以指定 <code>Easing</code> 来决定插值曲线。</p><p>指定 <code>0</code> 毫秒处和持续时间处的数值是可选的。如果你不指定这些值，它们将分别默认为动画的开始和结束值。</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">val value by animateFloatAsState(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    targetValue = 1f,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    animationSpec = keyframes {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        durationMillis = 375</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        0.0f at 0 with LinearOutSlowInEasing</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        0.2f at 15 with FastOutLinearInEasing</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        0.4f at 75</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        0.4f at 225</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p><strong>repeatable</strong></p><p><code>repeatable</code> 重复运行一个基于持续时间的动画（比如 <code>Tween</code> 或关键帧），直到它达到指定的迭代次数。你可以通过 <code>repeatMode</code> 参数来指定动画是否应该从开始 <code>RepeatMode.Restart</code> 或从结束 <code>RepeatMode.Reverse</code> 开始重复。</p><p><strong>infiniteRepeatable</strong></p><p><code>infiniteRepeatable</code> 和 <code>repeatable</code> 一样，但它会重复无限次的迭代。</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">val value by animateFloatAsState(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    targetValue = 1f,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    animationSpec = infiniteRepeatable(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        animation = tween(durationMillis = 300),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        repeatMode = RepeatMode.Reverse</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>在使用 <code>ComposeTestRule</code> 的测试中，使用 <code>infiniteRepeatable</code> 的动画不会被运行。该组件将使用每个动画值的初始值进行渲染。</p><p><strong>snap</strong></p><p><code>snap</code> 是一个特殊的 <code>AnimationSpec</code>，可以立即将值切换到结束值。你可以指定 <code>delayMillis</code>，以便延迟动画的开始。</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">val value by animateFloatAsState(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    targetValue = 1f,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    animationSpec = snap(delayMillis = 50)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><div class="admonition admonition-info alert alert--info"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>注意</h5></div><div class="admonition-content"><p>在 <code>View UI</code> 系统中，我们需要使用 <code>ObjectAnimator</code> 等来实现基于时间的动画，而 <code>SpringAnimation</code> 则是基于物理的动画。要同时使用这两个不同的动画 <code>API</code> 并不容易。<code>Compose</code> 中的 <code>AnimationSpec</code> 允许我们以一种统一的方式来处理这些。</p></div></div><h3 class="anchor anchorWithStickyNavbar_mojV" id="easing">Easing<a class="hash-link" href="#easing" title="Direct link to heading">​</a></h3><p>基于持续时间的 <code>AnimationSpec</code> 操作（如 <code>tween</code> 或 <code>keyframes</code>）使用 <code>Easing</code> 来调整动画的分数。这允许动画值加速和减速，而不是以一个恒定的速度移动。分数是一个介于 <code>0</code>（开始）和 <code>1.0</code>（结束）之间的数值，表示动画的当前点。</p><p><code>Easing</code> 实际上是一个函数，它接收一个介于 <code>0</code> 和 <code>1.0</code> 之间的分数值并返回一个浮点数。返回的值可以在边界之外，以表示过冲或下冲的情况。一个自定义的 <code>Easing</code> 可以像下面的代码一样被创建。</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">val CustomEasing = Easing { fraction -&gt; fraction * fraction }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Composable</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fun EasingUsage() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    val value by animateFloatAsState(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        targetValue = 1f,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        animationSpec = tween(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            durationMillis = 300,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            easing = CustomEasing</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // … …</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p><code>Compose</code> 提供了几个内置的 <code>Easing</code> 功能，涵盖了大多数使用情况。请参阅 <a href="https://material.io/design/motion/speed.html#easing" target="_blank" rel="noopener noreferrer">Speed Material Design</a>，了解更多关于根据你的情况使用何种 <code>Easing</code> 的信息。</p><ul><li>FastOutSlowInEasing</li><li>LinearOutSlowInEasing</li><li>FastOutLinearEasing</li><li>LinearEasing</li><li>CubicBezierEasing</li></ul><div class="admonition admonition-info alert alert--info"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>注意</h5></div><div class="admonition-content"><p> <code>Easing</code> 对象的工作方式与平台中 <code>Interpolator</code> 类的实例相同。它没有 <code>getInterpolation()</code> 方法，而是有 <code>transform()</code> 方法。</p></div></div><h3 class="anchor anchorWithStickyNavbar_mojV" id="animationvector">AnimationVector<a class="hash-link" href="#animationvector" title="Direct link to heading">​</a></h3><p>大多数 <code>Compose</code> 的动画 <code>API</code> 都支持 <code>Float</code>、<code>Color</code>、<code>Dp</code> 和其他基本数据类型作为开箱即用的动画值，但你有时需要对其他数据类型进行动画处理，包括你自定义的数据。在动画制作过程中，任何动画值都被表示为一个 <code>AnimationVector</code>。该值通过相应的 <code>TwoWayConverter</code> 转换为 <code>AnimationVector</code>，反之亦然，这样核心动画系统就可以统一处理它们。例如，一个 <code>Int</code> 被表示为一个 <code>AnimationVector1D</code>，它持有一个浮点值。<code>Int</code> 的 <code>TwoWayConverter</code> 看起来像这样。</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">val IntToVector: TwoWayConverter&lt;Int, AnimationVector1D&gt; =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    TwoWayConverter({ AnimationVector1D(it.toFloat()) }, { it.value.toInt() })</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>颜色本质上是一组 <code>4</code> 个值，红、绿、蓝和透明度，所以颜色被转换为一个 <code>AnimationVector4D</code>，持有 <code>4</code> 个浮点值。通过这种方式，动画中使用的每一种数据类型都被转换为 <code>AnimationVector1D</code>、<code>AnimationVector2D</code>、<code>AnimationVector3D</code> 或 <code>AnimationVector4D</code>，取决于其维度。这使得对象的不同组件可以独立地被动画化，每个组件都有自己的速度跟踪。基本数据类型的内置转换器可以使用 <code>Color.VectorConverter</code>、<code>Dp</code>、<code>VectorConverter</code> 等访问。</p><p>当你想添加对一个新的数据类型作为动画值的支持时，你可以创建你自己的 <code>TwoWayConverter</code> 并将其提供给 <code>API</code>。例如，你可以使用 <code>animateValueAsState</code> 来使你的自定义数据类型产生动画，像这样。</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">data class MySize(val width: Dp, val height: Dp)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Composable</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fun MyAnimation(targetSize: MySize) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    val animSize: MySize by animateValueAsState&lt;MySize, AnimationVector2D&gt;(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        targetSize,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        TwoWayConverter(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            convertToVector = { size: MySize -&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 从每个 Dp 字段中提取一个浮动值。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                AnimationVector2D(size.width.value, size.height.value)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            convertFromVector = { vector: AnimationVector2D -&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                MySize(vector.v1.dp, vector.v2.dp)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h2 class="anchor anchorWithStickyNavbar_mojV" id="5-手势与动画高级">5. 手势与动画（高级）<a class="hash-link" href="#5-手势与动画高级" title="Direct link to heading">​</a></h2><p>与单独处理动画相比，当我们处理触摸事件和动画时，有几件事我们必须考虑到。首先，当触摸事件开始时，我们可能需要中断正在进行的动画，因为用户互动应该有最高的优先权。</p><p>在下面的例子中，我们用一个 <code>Animatable</code> 来表示一个圆形组件的偏移位置。触摸事件是用 <code>pointerInput</code> 修改器来处理的。当我们检测到一个新的轻敲事件时，我们调用 <code>animateTo</code> 来将偏移值动画化到轻敲位置。敲击事件也可以在动画中发生，在这种情况下，<code>animateTo</code> 中断正在进行的动画，并开始动画到新的目标位置，同时保持中断的动画的速度。</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">@Composable</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fun Gesture() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    val offset = remember { Animatable(Offset(0f, 0f), Offset.VectorConverter) }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Box(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        modifier = Modifier</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            .fillMaxSize()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            .pointerInput(Unit) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                coroutineScope {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    while (true) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        // 检测一个点击头事件并获得其位置。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        val position = awaitPointerEventScope {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            awaitFirstDown().position</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        launch {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            // 应用到点击的位置。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            offset.animateTo(position)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Circle(modifier = Modifier.offset { offset.value.toIntOffset() })</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private fun Offset.toIntOffset() = IntOffset(x.roundToInt(), y.roundToInt())</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><img src="/assets/images/demo8-3f8af31951ea84127aecf27dc538ae39.gif"><p>另一个常见的模式是我们需要将动画值与来自触摸事件的值同步，例如拖动。在下面的例子中，我们看到 &quot;轻扫解散&quot; 作为一个修改器来实现（而不是使用 <code>SwipeToDismiss</code> 的组合）。该元素的水平偏移被表示为一个<code>Animatable</code>。这个 <code>API</code> 有一个在手势动画中有用的特性。它的值可以被触摸事件以及动画所改变。当我们收到一个触摸事件时，我们通过 <code>stop</code> 方法停止 <code>Animatable</code>，这样任何正在进行的动画就被拦截了。</p><p>在一个拖动事件中，我们用 <code>snapTo</code> 来更新 <code>Animatable</code> 的值，即从触摸事件中计算出来的值。对于拖动，<code>compose</code> 提供了 <code>VelocityTracker</code> 来记录拖动事件并计算出速度。速度可以直接反馈给<code>animateDecay</code>，用于制作翻转动画。当我们想把偏移值滑回到原始位置时，我们用 <code>animateTo</code> 方法指定目标偏移值为 <code>0f</code>。</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">fun Modifier.swipeToDismiss(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    onDismissed: () -&gt; Unit</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">): Modifier = composed {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    val offsetX = remember { Animatable(0f) }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    pointerInput(Unit) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        val decay = splineBasedDecay&lt;Float&gt;(this)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        coroutineScope {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            while (true) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 检测一个触摸事件。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                val pointerId = awaitPointerEventScope { awaitFirstDown().id }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                val velocityTracker = VelocityTracker()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 拦截一个正在进行的动画（如果有的话</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                offsetX.stop()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                awaitPointerEventScope {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    horizontalDrag(pointerId) { change -&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        // 用触摸事件更新动画值。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        launch {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            offsetX.snapTo(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                offsetX.value + change.positionChange().x</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        velocityTracker.addPosition(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            change.uptimeMillis,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            change.position</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                val velocity = velocityTracker.calculateVelocity().x</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                val targetOffsetX = decay.calculateTargetValue(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    offsetX.value,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    velocity</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 当它到达边界时，动画停止。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                offsetX.updateBounds(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    lowerBound = -size.width.toFloat(),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    upperBound = size.width.toFloat()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                launch {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    if (targetOffsetX.absoluteValue &lt;= size.width) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        // 速度不够；向后滑动。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        offsetX.animateTo(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            targetValue = 0f,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            initialVelocity = velocity</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        // 该元素被刷掉了。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        offsetX.animateDecay(velocity, decay)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        onDismissed()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .offset { IntOffset(offsetX.value.roundToInt(), 0) }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><img src="/assets/images/demo9-8a3cdf25bdfb789d6f93534f74644c45.gif"><h2 class="anchor anchorWithStickyNavbar_mojV" id="6-测试">6. 测试<a class="hash-link" href="#6-测试" title="Direct link to heading">​</a></h2><p><code>Compose</code> 提供了 <code>ComposeTestRule</code>，允许你以确定的方式为动画编写测试，并对测试时钟进行完全控制。这使你可以验证中间的动画值。此外，一个测试可以比动画的实际持续时间更快运行。</p><p><code>ComposeTestRule</code> 将其测试时钟公开为 <code>mainClock</code>。你可以将 <code>autoAdvance</code> 属性设置为 <code>false</code> 来控制你测试代码中的时钟。在启动你要测试的动画后，时钟可以用 <code>advanceTimeBy</code> 向前移动。</p><p>这里需要注意的一点是，<code>advanceTimeBy</code> 并不完全按照指定的持续时间来移动时钟。相反，它将其四舍五入到最近的持续时间，即帧持续时间的乘数。</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">@get:Rule</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">val rule = createComposeRule()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Test</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fun testAnimationWithClock() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 暂停动画</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    rule.mainClock.autoAdvance = false</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    var enabled by mutableStateOf(false)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    rule.setContent {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        val color by animateColorAsState(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            targetValue = if (enabled) Color.Red else Color.Green,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            animationSpec = tween(durationMillis = 250)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Box(Modifier.size(64.dp).background(color))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 启动动画</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    enabled = true</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 让动画继续进行。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    rule.mainClock.advanceTimeBy(50L)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 将结果与显示预期结果的图像进行比较。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    rule.onRoot().captureToImage().assertAgainstGolden()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/milklabdev/jetpack-compose-book/tree/master/docs/design/animation/overview.mdx" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_dcUD" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_foO9"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/docs/category/动画animation"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">动画（Animation）</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/docs/design/animation/animationVisibility"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">AnimationVisibility（实验性）</div></a></div></nav></div></div><div class="col col--3"><div class="tableOfContents_cNA8 thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#2-高级动画-api" class="table-of-contents__link toc-highlight">2. 高级动画 API</a><ul><li><a href="#animatedvisibiliy-实验性" class="table-of-contents__link toc-highlight">AnimatedVisibiliy (实验性)</a></li><li><a href="#animatecontentsize" class="table-of-contents__link toc-highlight">animateContentSize</a></li><li><a href="#crossfade" class="table-of-contents__link toc-highlight">Crossfade</a></li></ul></li><li><a href="#3-低级动画-api" class="table-of-contents__link toc-highlight">3. 低级动画 API</a><ul><li><a href="#animateasstate" class="table-of-contents__link toc-highlight">animate*AsState</a></li><li><a href="#animatable" class="table-of-contents__link toc-highlight">Animatable</a></li><li><a href="#updatetransition" class="table-of-contents__link toc-highlight">updateTransition</a></li><li><a href="#rememberinfinitetransition" class="table-of-contents__link toc-highlight">rememberInfiniteTransition</a></li><li><a href="#targetbasedanimation" class="table-of-contents__link toc-highlight">TargetBasedAnimation</a></li></ul></li><li><a href="#4-自定义动画" class="table-of-contents__link toc-highlight">4. 自定义动画</a><ul><li><a href="#animationspec" class="table-of-contents__link toc-highlight">AnimationSpec</a></li><li><a href="#easing" class="table-of-contents__link toc-highlight">Easing</a></li><li><a href="#animationvector" class="table-of-contents__link toc-highlight">AnimationVector</a></li></ul></li><li><a href="#5-手势与动画高级" class="table-of-contents__link toc-highlight">5. 手势与动画（高级）</a></li><li><a href="#6-测试" class="table-of-contents__link toc-highlight">6. 测试</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">社区</div><ul class="footer__items"><li class="footer__item"><a href="https://github.com/milklabdev" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Github<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2022 Milk Lab, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.003b15d9.js"></script>
<script src="/assets/js/main.3ccbd39c.js"></script>
</body>
</html>