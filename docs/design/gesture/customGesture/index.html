<!doctype html>
<html class="docs-version-current" lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.15">
<title data-react-helmet="true">自定义触摸反馈 | 你好 Compose</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:url" content="https://milklab.dev/docs/design/gesture/customGesture"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="自定义触摸反馈 | 你好 Compose"><meta data-react-helmet="true" name="description" content="Jetpack Compose 为我们提供了许多手势处理 Modifier，对于常见业务需求来说已足够我们使用了，然而如果说我们对手势有定制需求，就需要具备自定义手势处理的能力了。通过使用官方所提供的基础 API 来完成各类手势交互需求，触摸反馈基础 API 类似传统 View 系统的 onTouchEvent()。 当然 Compose 中也支持类似传统 ViewGroup 通过 onInterceptTouchEvent()定制手势事件分发流程。通过对自定义手势处理的学习将帮助大家掌握处理绝大多数场景下手势需求的能力。"><meta data-react-helmet="true" property="og:description" content="Jetpack Compose 为我们提供了许多手势处理 Modifier，对于常见业务需求来说已足够我们使用了，然而如果说我们对手势有定制需求，就需要具备自定义手势处理的能力了。通过使用官方所提供的基础 API 来完成各类手势交互需求，触摸反馈基础 API 类似传统 View 系统的 onTouchEvent()。 当然 Compose 中也支持类似传统 ViewGroup 通过 onInterceptTouchEvent()定制手势事件分发流程。通过对自定义手势处理的学习将帮助大家掌握处理绝大多数场景下手势需求的能力。"><link data-react-helmet="true" rel="icon" href="/img/logo.svg"><link data-react-helmet="true" rel="canonical" href="https://milklab.dev/docs/design/gesture/customGesture"><link data-react-helmet="true" rel="alternate" href="https://milklab.dev/docs/design/gesture/customGesture" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://milklab.dev/docs/design/gesture/customGesture" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.cba56bc1.css">
<link rel="preload" href="/assets/js/runtime~main.279986bd.js" as="script">
<link rel="preload" href="/assets/js/main.387f3f8c.js" as="script">
</head>
<body data-theme="light">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region"><a href="#" class="skipToContent_ZgBM">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_W2Cr themedImage--light_TfLj"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_W2Cr themedImage--dark_oUvU"></div><b class="navbar__title">Jetpack Compose 博物馆</b></a><a class="navbar__item navbar__link navbar__link--active" href="/docs/">文档</a><a class="navbar__item navbar__link" href="/docs/open-source-project/compose-douban">开源项目</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/milklabdev/jetpack-compose-book" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><div class="toggle_Pssr toggle_TdHA toggleDisabled_jDku"><div class="toggleTrack_SSoT" role="button" tabindex="-1"><div class="toggleTrackCheck_XobZ"><span class="toggleIcon_eZtF">🌜</span></div><div class="toggleTrackX_YkSC"><span class="toggleIcon_eZtF">🌞</span></div><div class="toggleTrackThumb_uRm4"></div></div><input type="checkbox" class="toggleScreenReader_JnkT" aria-label="Switch between dark and light mode"></div><div class="dsla-search-wrapper"><div class="dsla-search-field" data-tags="default,docs-default-current"></div></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docs-wrapper docs-doc-page"><div class="docPage_P2Lg"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_RiI4" type="button"></button><aside class="theme-doc-sidebar-container docSidebarContainer_rKC_"><div class="sidebar_CW9Y"><nav class="menu thin-scrollbar menu_SkdO"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/">写在开头</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link hasHref_VCh3" href="/docs/category/入门">入门</a><button aria-label="Toggle the collapsible sidebar category &#x27;入门&#x27;" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/installation">安装或更新 Android Studio</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/tutorial">初识 Jetpack Compose</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" href="/docs/elements/alertdialog">基础组件</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" href="/docs/layout/box">布局组件</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--active hasHref_VCh3" aria-current="page" href="/docs/category/设计">设计</a><button aria-label="Toggle the collapsible sidebar category &#x27;设计&#x27;" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link hasHref_VCh3" tabindex="0" href="/docs/category/动画animation">动画（Animation）</a><button aria-label="Toggle the collapsible sidebar category &#x27;动画（Animation）&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link hasHref_VCh3" tabindex="0" href="/docs/category/主题theming">主题（Theming）</a><button aria-label="Toggle the collapsible sidebar category &#x27;主题（Theming）&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--active hasHref_VCh3" aria-current="page" tabindex="0" href="/docs/category/手势gesture">手势（Gesture）</a><button aria-label="Toggle the collapsible sidebar category &#x27;手势（Gesture）&#x27;" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/design/gesture/overview">概述</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/design/gesture/draggable">拖动（Draggable）</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/design/gesture/swipeable">滑动（Swipeable）</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/design/gesture/transformer">双指拖动、缩放与旋转（Transformer）</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/design/gesture/nestedScroll">嵌套滑动（nestedScroll）</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/design/gesture/customGesture">自定义触摸反馈</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link hasHref_VCh3" tabindex="0" href="/docs/category/列表lists">列表（Lists）</a><button aria-label="Toggle the collapsible sidebar category &#x27;列表（Lists）&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link hasHref_VCh3" tabindex="0" href="/docs/category/图形graphics">图形（Graphics）</a><button aria-label="Toggle the collapsible sidebar category &#x27;图形（Graphics）&#x27;" type="button" class="clean-btn menu__caret"></button></div></li></ul></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/resources">资源</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link hasHref_VCh3" href="/docs/category/技术原理">技术原理</a><button aria-label="Toggle the collapsible sidebar category &#x27;技术原理&#x27;" type="button" class="clean-btn menu__caret"></button></div></li></ul></nav></div></aside><main class="docMainContainer_TCnq"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_DM6M"><div class="docItemContainer_vinB"><article><div class="tocCollapsible_jdIR theme-doc-toc-mobile tocMobile_TmEX"><button type="button" class="clean-btn tocCollapsibleButton_Fzxq">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>自定义触摸反馈</h1></header><p>Jetpack Compose 为我们提供了许多手势处理 Modifier，对于常见业务需求来说已足够我们使用了，然而如果说我们对手势有定制需求，就需要具备自定义手势处理的能力了。通过使用官方所提供的基础 API 来完成各类手势交互需求，触摸反馈基础 API 类似传统 View 系统的 <code>onTouchEvent()</code>。 当然 Compose 中也支持类似传统 ViewGroup 通过 <code>onInterceptTouchEvent()</code>定制手势事件分发流程。通过对自定义手势处理的学习将帮助大家掌握处理绝大多数场景下手势需求的能力。</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="使用-pointerinput-modifier">使用 PointerInput Modifier<a class="hash-link" href="#使用-pointerinput-modifier" title="Direct link to heading">​</a></h2><p>对于所有手势操作的处理都需要封装在这个 Modifier 中，我们知道 Modifier 是用来修饰 UI 组件的，所以将手势操作的处理封装在 Modifier 符合开发者设计直觉，这同时也做到了手势处理逻辑与 UI 视图的解耦，从而提高复用性。</p><p>通过翻阅 <code>Swipeable Modifier</code> 、<code>Draggable Modifier </code> 以及 <code>Transformer Modifier</code>，我们都能看到 <code>PointerInput Modifier</code> 的身影。因为这类上层的手势处理 Modifier 其实都是基于这个基础 Modifier 实现的。所以既然要自定义手势处理流程，自定义逻辑也必然要在这个 Modifier 中进行实现。</p><p>通过 <code>PointerInput Modifier</code> 实现我们可以看出，我们所定义的自定义手势处理流程均发生在 <code>PointerInputScope</code> 中，suspend 关键字也告知我们自定义手势处理流程是发生在协程中。这其实是无可厚非的，在探索重组工作原理的过程中我们也经常能够看到协程的身影。伴随着越来越多的主流开发技术拥抱协程，这也就意味着协程成了 Android 开发者未来必须掌握的技能。推广协程同时其实也是在推广 Kotlin，即使官方一直强调不会放弃 Java，然而谁又会在 Java 中使用 Kotlin 协程呢？ </p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">fun Modifier.pointerInput(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    vararg keys: Any?,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    block: suspend PointerInputScope.() -&gt; Unit</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">): Modifier = composed(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    remember(density) { SuspendingPointerInputFilter(viewConfiguration, density) }.apply {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        LaunchedEffect(this, *keys) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            block()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>接下来我们就看看 <code>PointerInputScope</code> 作用域中，为我们可以使用哪些 API 来处理手势交互。本文将会根据手势能力分类进行解释说明。</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="拖动类型基础-api">拖动类型基础 API<a class="hash-link" href="#拖动类型基础-api" title="Direct link to heading">​</a></h3><h4 class="anchor anchorWithStickyNavbar_mojV" id="api-介绍">API 介绍<a class="hash-link" href="#api-介绍" title="Direct link to heading">​</a></h4><table><thead><tr><th>API名称</th><th>作用</th></tr></thead><tbody><tr><td>detectDragGestures</td><td>监听拖动手势</td></tr><tr><td>detectDragGesturesAfterLongPress</td><td>监听长按后的拖动手势</td></tr><tr><td>detectHorizontalDragGestures</td><td>监听水平拖动手势</td></tr><tr><td>detectVerticalDragGestures</td><td>监听垂直拖动手势</td></tr></tbody></table><p>谈及拖动，许多人第一个反应就是 <code>Draggable Modifier</code>，因为 <code>Draggable Modifier</code> 为我们提供了监听 UI 组件拖动能力。然而 <code>Draggable Modifier</code> 在提供了监听 UI 组件拖动能力的同时也拓展增加其他功能，我们通过 <code>Draggable Modifier</code> 参数列表即可看出。例如通过使用 <code>DraggableState</code> 允许开发者根据需求使 UI 组件自动被拖动。</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">fun Modifier.draggable(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    state: DraggableState,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    orientation: Orientation,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    enabled: Boolean = true,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    interactionSource: MutableInteractionSource? = null,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    startDragImmediately: Boolean = false,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    onDragStarted: suspend CoroutineScope.(startedPosition: Offset) -&gt; Unit = {},</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    onDragStopped: suspend CoroutineScope.(velocity: Float) -&gt; Unit = {},</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    reverseDirection: Boolean = false</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>我们上面所罗列的这些拖动 API 只提供了监听 UI 组件拖动的能力，我们可以根据需求为其拓展功能，这也是这些API所存在的意义。我们从字面上就可以看出每个 API 所对应的含义，由于这些API的功能与参数相近，这里我们仅以 <code>detectDragGestures</code> 作为举例说明。</p><h4 class="anchor anchorWithStickyNavbar_mojV" id="举例说明">举例说明<a class="hash-link" href="#举例说明" title="Direct link to heading">​</a></h4><p>接下来我们将完成一个绿色方块的手势拖动。在 <code>Draggabel Modifier</code> 中我们还只能监听垂直或水平中某一个方向的手势拖动，而使用 <code>detectDragGestures</code> 所有手势信息都是可以拿到的。如果我们还是只希望拿到某一个方向的手势拖动，使用 <code>detectHorizontalDragGestures</code>  或 <code>detectVerticalDragGestures</code> 即可，当然我们也可以使用 <code>detectDragGestures</code> 并且忽略掉某个方向的手势信息。如果我们希望在长按后才能拿到手势信息可以使用 <code>detectDragGesturesAfterLongPress</code>。</p><p><code>detectDragGestures</code> 提供了四个参数。</p><p>onDragStart (可选)：拖动开始时回调</p><p>onDragEnd (可选)：拖动结束时回调</p><p>onDragCancel (可选)：拖动取消时回调</p><p>onDrag (必须)：拖动时回调</p><p><code>decectDragGestures</code> 的源码分析在 <em>awaitTouchSlopOrCancellation</em> 小节会有讲解。</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">suspend fun PointerInputScope.detectDragGestures(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    onDragStart: (Offset) -&gt; Unit = { },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    onDragEnd: () -&gt; Unit = { },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    onDragCancel: () -&gt; Unit = { },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    onDrag: (change: PointerInputChange, dragAmount: Offset) -&gt; Unit</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><blockquote><p>💡 <strong>Tips </strong></p><p>有些同学可能困惑 <code>onDragCancel</code> 触发时机。在一些场景中，当组件拖动时会根据事件分发顺序进行事件分发，当前面先处理事件的组件满足了设置的消费条件，导致手势事件被消费，导致本组件拿到的是被消费的手势事件，从而会执行 <code>onDragCancel</code> 回调。如何定制事件分发顺序并消费事件后续会进行详细的描述。</p></blockquote><p>示例如下所示</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">@Preview</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Composable</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fun DragGestureDemo() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    var boxSize = 100.dp</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    var offset by remember { mutableStateOf(Offset.Zero) }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Box(contentAlignment = Alignment.Center,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        modifier = Modifier.fillMaxSize()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Box(Modifier</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            .size(boxSize)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            .offset {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                IntOffset(offset.x.roundToInt(), offset.y.roundToInt())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            .background(Color.Green)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            .pointerInput(Unit) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                detectDragGestures(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    onDragStart = { offset -&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        // 拖动开始</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    onDragEnd = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        // 拖动结束</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    onDragCancel = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        // 拖动取消</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    onDrag = { change: PointerInputChange, dragAmount: Offset -&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        // 拖动时</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        offset += dragAmount</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><div align="center"><img src="/assets/images/drag-80a95888973e3f8aff22b90304b4086d.gif" width="50%" height="50%"></div><h3 class="anchor anchorWithStickyNavbar_mojV" id="点击类型基础-api">点击类型基础 API<a class="hash-link" href="#点击类型基础-api" title="Direct link to heading">​</a></h3><h4 class="anchor anchorWithStickyNavbar_mojV" id="api-介绍-1">API 介绍<a class="hash-link" href="#api-介绍-1" title="Direct link to heading">​</a></h4><table><thead><tr><th>API名称</th><th>作用</th></tr></thead><tbody><tr><td>detectTapGestures</td><td>监听点击手势</td></tr></tbody></table><p>与 <code>Clickable Modifier</code> 不同的是，<code>detectTapGestures</code> 可以监听更多的点击事件。作为手机监听的基础 API，必然不会存在 <code>Clickable Modifier</code> 所拓展的涟漪效果。</p><h4 class="anchor anchorWithStickyNavbar_mojV" id="举例说明-1">举例说明<a class="hash-link" href="#举例说明-1" title="Direct link to heading">​</a></h4><p>接下来我们将为一个绿色方块添加点击手势处理逻辑。<code>detectTapGestures</code> 提供了四个可选参数，用来监听不同点击事件。</p><p>onDoubleTap (可选)：双击时回调</p><p>onLongPress (可选)：长按时回调</p><p>onPress (可选)：按下时回调</p><p>onTap (可选)：轻触时回调</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">suspend fun PointerInputScope.detectTapGestures(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    onDoubleTap: ((Offset) -&gt; Unit)? = null,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    onLongPress: ((Offset) -&gt; Unit)? = null,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    onPress: suspend PressGestureScope.(Offset) -&gt; Unit = NoPressGesture,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    onTap: ((Offset) -&gt; Unit)? = null</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><blockquote><p>💡 <strong>Tips </strong> </p><p>onPress 普通按下事件</p><p>onDoubleTap 前必定会先回调 2 次 Press</p><p>onLongPress 前必定会先回调 1 次 Press（时间长）</p><p>onTap 前必定会先回调 1 次 Press（时间短）</p></blockquote><p>示例如下所示</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">@Preview</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Composable</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fun TapGestureDemo() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    var boxSize = 100.dp</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Box(Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Box(Modifier</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            .size(boxSize)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            .background(Color.Green)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            .pointerInput(Unit) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                detectTapGestures(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    onDoubleTap = { offset: Offset -&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        // 双击</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    onLongPress = { offset: Offset -&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        // 长按</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    onPress = {  offset: Offset -&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        // 按下</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    onTap = {  offset: Offset -&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        // 轻触</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_mojV" id="变换类型基础-api">变换类型基础 API<a class="hash-link" href="#变换类型基础-api" title="Direct link to heading">​</a></h3><h4 class="anchor anchorWithStickyNavbar_mojV" id="api-介绍-2">API 介绍<a class="hash-link" href="#api-介绍-2" title="Direct link to heading">​</a></h4><table><thead><tr><th>API名称</th><th>作用</th></tr></thead><tbody><tr><td>detectTransformGestures</td><td>监听拖动、缩放与旋转手势</td></tr></tbody></table><p>与 <code>Transfomer Modifier</code> 不同的是，通过这个 API 可以监听单指的拖动手势，和拖动类型基础 API所提供的功能一样，除此之外还支持监听双指缩放与旋转手势。反观<code>Transfomer Modifier</code> 只能监听到双指拖动手势，不知设计成这样的行为不一致是否是 Google 有意而为之。</p><h4 class="anchor anchorWithStickyNavbar_mojV" id="举例说明-2">举例说明<a class="hash-link" href="#举例说明-2" title="Direct link to heading">​</a></h4><p>接下来我们为这个绿色方块添加变化手势处理逻辑。<code>detectTransformGestures</code> 方法提供了两个参数。</p><p>panZoomLock(可选)： 当拖动或缩放手势发生时是否支持旋转</p><p>onGesture(必须)：当拖动、缩放或旋转手势发生时回调</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">suspend fun PointerInputScope.detectTransformGestures(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    panZoomLock: Boolean = false,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    onGesture: (centroid: Offset, pan: Offset, zoom: Float, rotation: Float) -&gt; Unit</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><blockquote><p>💡 <strong>Tips</strong></p><p>关于偏移、缩放与旋转，我们建议的调用顺序是 rotate -&gt; scale -&gt; offset</p><ol><li><p>若offset发生在rotate之前时，rotate会对offset造成影响。具体表现为当出现拖动手势时，组件会以当前角度为坐标轴进行偏移。</p></li><li><p>若offset发生在scale之前时，scale也会对offset造成影响。具体表现为UI组件在拖动时不跟手</p></li></ol></blockquote><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">@Preview</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Composable</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fun TransformGestureDemo() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    var boxSize = 100.dp</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    var offset by remember { mutableStateOf(Offset.Zero) }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    var ratationAngle by remember { mutableStateOf(0f) }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    var scale by remember { mutableStateOf(1f) }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Box(Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Box(Modifier</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            .size(boxSize)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            .rotate(ratationAngle) // 需要注意offset与rotate的调用先后顺序</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            .scale(scale)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            .offset {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                IntOffset(offset.x.roundToInt(), offset.y.roundToInt())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            .background(Color.Green)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            .pointerInput(Unit) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                detectTransformGestures(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    panZoomLock = true, // 平移或放大时是否可以旋转</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    onGesture = { centroid: Offset, pan: Offset, zoom: Float, rotation: Float -&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        offset += pan</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        scale *= zoom</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        ratationAngle += rotation</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><div align="center"><img src="/assets/images/transform-9b4172346bc8c9ecb20cb96966e06fc0.gif" width="50%" height="50%"></div><h3 class="anchor anchorWithStickyNavbar_mojV" id="foreachgesture">forEachGesture<a class="hash-link" href="#foreachgesture" title="Direct link to heading">​</a></h3><p>在传统 View 系统中，一次手指按下、移动到抬起过程中的所有手势事件可以共同构成一个手势事件序列。我们可以通过自定义手势处理来对于每一个手势事件序列进行定制处理。Compose 提供了 <code>forEachGesture</code> 以允许用户可以对每一个手势事件序列进行相同的定制处理。如果我们忘记使用 <code>forEachGesture</code> ，那么只会处理第一次手势事件序列。有些同学可能会问，为什么我不能在手势处理逻辑最外层套一层 <code>while(true) </code> 呢，通过 <code>forEachGesture</code> 的实现我们可以看到 <code>forEachGesture</code> 其实内部也是由<code>while </code> 实现的，除此之外他保证了协程只有存活时才能监听手势事件，同时也保证了每次交互结束时所有手指都是离开屏幕的。有些同学看到 <code>while</code> 可能新生疑问，难道这样不会阻塞主线程嘛？其实我们在介绍 <code>PointerInput Modifier</code> 时就提到过，我们的手势操作处理均发生在协程中。其实前面我们所提到的绝大多数 API 其内部实现均使用了 <code>forEachGesture</code> 。有些特殊场景下我们仅使用前面所提出的 API 可能仍然无法满足我们的需求，当然如果可以满足的话我们直接使用其分别对应的 <code>Modifier</code> 即可，前面所提出的 API 存在的意义是为了方便开发者为其进行功能拓展。既然要掌握自定义手势处理，我们就要从更底层角度来看这些上层 API 是如何实现的，了解原理我们就可以轻松自定义了。</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">suspend fun PointerInputScope.forEachGesture(block: suspend PointerInputScope.() -&gt; Unit) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    val currentContext = currentCoroutineContext()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    while (currentContext.isActive) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            block()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 挂起等待所有手指抬起</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            awaitAllPointersUp()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } catch (e: CancellationException) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h2 class="anchor anchorWithStickyNavbar_mojV" id="手势事件作用域-awaitpointereventscope">手势事件作用域 awaitPointerEventScope<a class="hash-link" href="#手势事件作用域-awaitpointereventscope" title="Direct link to heading">​</a></h2><p>在 <code>PointerInputScope</code> 中我们可以找到一个名为 <code>awaitPointerEventScope</code> 的 API 方法。</p><p>通过翻阅方法声明可以发现这是个挂起方法，其尾部 lambda 在 <code>AwaitPointerEventScope</code> 作用域中。 通过这个 <code>AwaitPointerEventScope</code> 作用域我们可以获取到更加底层的 API 手势事件，这也为自定义手势处理提供了可能。</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">suspend fun &lt;R&gt; awaitPointerEventScope(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    block: suspend AwaitPointerEventScope.() -&gt; R</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">): R</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>我们在 <code>AwaitPointerEventScope</code> 中发现了以下这些基础手势方法，可以发现这些 API 均是挂起函数，接下来我们会对每个 API 进行描述说明。</p><table><thead><tr><th>API名称</th><th>作用</th></tr></thead><tbody><tr><td>awaitPointerEvent</td><td>手势事件</td></tr><tr><td>awaitFirstDown</td><td>第一根手指的按下事件</td></tr><tr><td>drag</td><td>拖动事件</td></tr><tr><td>horizontalDrag</td><td>水平拖动事件</td></tr><tr><td>verticalDrag</td><td>垂直拖动事件</td></tr><tr><td>awaitDragOrCancellation</td><td>单次拖动事件</td></tr><tr><td>awaitHorizontalDragOrCancellation</td><td>单次水平拖动事件</td></tr><tr><td>awaitVerticalDragOrCancellation</td><td>单次垂直拖动事件</td></tr><tr><td>awaitTouchSlopOrCancellation</td><td>有效拖动事件</td></tr><tr><td>awaitHorizontalTouchSlopOrCancellation</td><td>有效水平拖动事件</td></tr><tr><td>awaitVerticalTouchSlopOrCancellation</td><td>有效垂直拖动事件</td></tr></tbody></table><h3 class="anchor anchorWithStickyNavbar_mojV" id="万物之源-awaitpointerevent">万物之源 awaitPointerEvent<a class="hash-link" href="#万物之源-awaitpointerevent" title="Direct link to heading">​</a></h3><p><code>awaitPointerEvent</code> 类似于传统 View 系统的 <code>onTouchEvent()</code> 。无论用户是按下、移动或抬起都将视作一次手势事件，当手势事件发生时 <code>awaitPointerEvent</code> 会恢复执行并将手势事件返回。</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">suspend fun awaitPointerEvent(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  pass: PointerEventPass = PointerEventPass.Main</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">): PointerEvent</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>通过 API 声明可以看到 <code>awaitPointerEvent</code> 有个可选参数 <code>PointerEventPass</code></p><p>我们知道手势事件的分发是由父组件到子组件的单链结构。这个参数目的是用以设置父组件与子组件的事件分发顺序，<code>PointerEventPass</code> 有 3 个枚举值可供选择，每个枚举值的具体含义如下</p><table><thead><tr><th>枚举值</th><th>含义</th></tr></thead><tbody><tr><td>PointerEventPass.Initial</td><td>本组件优先处理手势，处理后交给子组件</td></tr><tr><td>PointerEventPass.Main</td><td>若子组件为Final，本组件优先处理手势。否则将手势交给子组件处理，结束后本组件再处理。</td></tr><tr><td>PointerEventPass.Final</td><td>若子组件也为Final，本组件优先处理手势。否则将手势交给子组件处理，结束后本组件再处理。</td></tr></tbody></table><p>大家可能觉得 Main 与 Final 是等价的。但其实两者在作为子组件时分发顺序会完全不同，举个例子。</p><p>当父组件为Final，子组件为Main时，事件分发顺序： 子组件  -&gt; 父组件</p><p>当父组件为Final，子组件为Final时，事件分发顺序： 父组件 -&gt; 子组件</p><p>文字描述可能并不直观，接下来进行举例说明。</p><h4 class="anchor anchorWithStickyNavbar_mojV" id="事件分发流程">事件分发流程<a class="hash-link" href="#事件分发流程" title="Direct link to heading">​</a></h4><p>接下来，我将通过一个嵌套了三层 Box 的示例来直观表现事件分发过程。我们为这嵌套的三层Box 中的每一层都进行手势获取。</p><img src="/assets/images/box_nest-ae9dd4c99af7a066741ffdf0aceb94fe.jpg" width="50%" height="50%"><p>如果我们点击中间的绿色方块时，便会触发手势事件。</p><p>当三层 Box 均使用默认 Main 模式时，事件分发顺序为：第三层 -&gt; 第二层 -&gt; 第一层</p><p>当第一层Box使用 Inital 模式，第二层使用 Final 模式，第三层使用 Main 模式时，事件分发顺序为：第一层 -&gt; 第三层 -&gt; 第二层</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">@Preview</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Composable</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fun NestedBoxDemo() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Box(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        contentAlignment = Alignment.Center,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        modifier = Modifier</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            .fillMaxSize()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            .pointerInput(Unit) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                awaitPointerEventScope {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    awaitPointerEvent(PointerEventPass.Initial)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    Log.d(&quot;compose_study&quot;, &quot;first layer&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Box(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            contentAlignment = Alignment.Center,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            modifier = Modifier</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                .size(400.dp)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                .background(Color.Blue)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                .pointerInput(Unit) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    awaitPointerEventScope {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        awaitPointerEvent(PointerEventPass.Final)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        Log.d(&quot;compose_study&quot;, &quot;second layer&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Box(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                Modifier</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    .size(200.dp)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    .background(Color.Green)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    .pointerInput(Unit) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        awaitPointerEventScope {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            awaitPointerEvent()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            Log.d(&quot;compose_study&quot;, &quot;third layer&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Output:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// first layer</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// third layer</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// second layer</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>能够自定义事件分发顺序之后，我们就可以决定手势事件由事件分发流程中哪个组件进行消费。那么如何进行消费呢，这就需要我们看看 <code>awaitPointerEvent</code> 返回的手势事件了。通过 <code>awaintPointerEvent</code> 声明，我们可以看到返回的手势事件是个 <code>PointerEvent</code> 实例。</p><p>通过 <code>PointerEvent</code> 类声明，我们可以看到两个成员属性 changes 与 motionEvent。</p><p>motionEvent 我们再熟悉不过了，就是传统 View 系统中的手势事件，然而却被声明了 internal 关键字，看来是不希望我们使用。</p><p>changes 是一个 List，其中包含了每次发生手势事件时，屏幕上所有手指的状态信息。</p><p>当只有一根手指时，这个 List 的大小为 1。在多指操作时，我们通过这个 List 获取其他手指的状态信息就可以轻松定制多指自定义手势处理了。</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">actual data class PointerEvent internal constructor(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    actual val changes: List&lt;PointerInputChange&gt;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    internal val motionEvent: MotionEvent?</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h4 class="anchor anchorWithStickyNavbar_mojV" id="pointerinputchange">PointerInputChange<a class="hash-link" href="#pointerinputchange" title="Direct link to heading">​</a></h4><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">class PointerInputChange(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    val id: PointerId, // 手指Id</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    val uptimeMillis: Long, // 当前手势事件的时间戳</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    val position: Offset, // 当前手势事件相对组件左上角的位置</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    val pressed: Boolean, // 当前手势是否按下</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    val previousUptimeMillis: Long, // 上一次手势事件的时间戳</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    val previousPosition: Offset, // 上一次手势事件相对组件左上角的位置</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    val previousPressed: Boolean, // 上一次手势是否按下</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    val consumed: ConsumedData, // 当前手势是否已被消费</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    val type: PointerType = PointerType.Touch // 手势类型(鼠标、手指、手写笔、橡皮) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><table><thead><tr><th>API名称</th><th>作用</th></tr></thead><tbody><tr><td>changedToDown</td><td>是否已经按下(按下手势已消费则返回false)</td></tr><tr><td>changedToDownIgnoreConsumed</td><td>是否已经按下(忽略按下手势已消费标记)</td></tr><tr><td>changedToUp</td><td>是否已经抬起(按下手势已消费则返回false)</td></tr><tr><td>changedToUpIgnoreConsumed</td><td>是否已经抬起(忽略按下手势已消费标记)</td></tr><tr><td>positionChanged</td><td>是否位置发生了改变(移动手势已消费则返回false)</td></tr><tr><td>positionChangedIgnoreConsumed</td><td>是否位置发生了改变(忽略已消费标记)</td></tr><tr><td>positionChange</td><td>位置改变量(移动手势已消费则返回Offset.Zero)</td></tr><tr><td>positionChangeIgnoreConsumed</td><td>位置改变量(忽略移动手势已消费标记)</td></tr><tr><td>positionChangeConsumed</td><td>当前移动手势是否已被消费</td></tr><tr><td>anyChangeConsumed</td><td>当前按下手势或移动手势是否有被消费</td></tr><tr><td>consumeDownChange</td><td>消费按下手势</td></tr><tr><td>consumePositionChange</td><td>消费移动手势</td></tr><tr><td>consumeAllChanges</td><td>消费按下与移动手势</td></tr><tr><td>isOutOfBounds</td><td>当前手势是否在固定范围内</td></tr></tbody></table><p>这些 API 会在我们自定义手势处理时会被用到。可以发现的是，Compose 通过 <code>PointerEventPass</code> 来定制事件分发流程，在事件分发流程中即使前一个组件先获取了手势信息并进行了消费，后面的组件仍然可以通过带有 <code>IgnoreConsumed</code> 系列 API 来获取到手势信息。这也极大增加了手势操作的可定制性。就好像父组件先把事件消费，希望子组件不要处理这个手势了，但子组件完全可以不用听从父组件的话。</p><p>我们通过一个实例来看看该如何进行手势消费，处于方便我们的示例不涉及移动，只消费按下手势事件来进行举例。和之前的样式一样，我们将手势消费放在了第三层 Box，根据事件分发规则我们知道第三层Box是第2个处理手势事件的，所以输出结果如下。</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">@Preview</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Composable</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fun Demo() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Box(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        contentAlignment = Alignment.Center,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        modifier = Modifier</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            .fillMaxSize()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            .pointerInput(Unit) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                awaitPointerEventScope {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    var event = awaitPointerEvent(PointerEventPass.Initial)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    Log.d(&quot;compose_study&quot;, &quot;first layer, downChange: ${event.changes[0].consumed.downChange}&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Box(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            contentAlignment = Alignment.Center,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            modifier = Modifier</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                .size(400.dp)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                .background(Color.Blue)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                .pointerInput(Unit) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    awaitPointerEventScope {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        var event = awaitPointerEvent(PointerEventPass.Final)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        Log.d(&quot;compose_study&quot;, &quot;second layer, downChange: ${event.changes[0].consumed.downChange}&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Box(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                Modifier</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    .size(200.dp)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    .background(Color.Green)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    .pointerInput(Unit) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        awaitPointerEventScope {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            var event = awaitPointerEvent()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            event.changes[0].consumeDownChange()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            Log.d(&quot;compose_study&quot;, &quot;third layer, downChange: ${event.changes[0].consumed.downChange}&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Output:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// first layer, downChange: false</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// third layer, downChange: true</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// second layer, downChange: true</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>⚠️ <strong>注意事项</strong></p><p>如果我们是在定制事件分发流程，那么需要注意以下两种写法</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">// 正确写法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">awaitPointerEventScope {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    var event = awaitPointerEvent() </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    event.changes[0].consumeDownChange()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 错误写法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">var event = awaitPointerEventScope {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    awaitPointerEvent()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">event.changes[0].consumeDownChange()</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>他们的区别在于 <code>awaitPointerEventScope</code> 会在其内部所有手势在事件分发流程结束后返回，当所有组件都已经完成手势处理再进行消费已经没有什么意义了。我们仍然用刚才的例子来直观说明这个问题。我们在每一层Box <code>awaitPointerEventScope</code> 后面添加了日志信息。</p><p>通过输出结果可以发现，这三层执行的相对顺序没有发生变化，然而却是在事件分发流程结束后才进行输出的。</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">@Preview</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Composable</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fun Demo() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Box(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        contentAlignment = Alignment.Center,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        modifier = Modifier</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            .fillMaxSize()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            .pointerInput(Unit) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                awaitPointerEventScope {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    var event = awaitPointerEvent(PointerEventPass.Initial)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    Log.d(&quot;compose_study&quot;, &quot;first layer, downChange: ${event.changes[0].consumed.downChange}&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                Log.d(&quot;compose_study&quot;, &quot;first layer Outside&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Box(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            contentAlignment = Alignment.Center,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            modifier = Modifier</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                .size(400.dp)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                .background(Color.Blue)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                .pointerInput(Unit) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    awaitPointerEventScope {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        var event = awaitPointerEvent(PointerEventPass.Final)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        Log.d(&quot;compose_study&quot;, &quot;second layer, downChange: ${event.changes[0].consumed.downChange}&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    Log.d(&quot;compose_study&quot;, &quot;second layer Outside&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Box(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                Modifier</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    .size(200.dp)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    .background(Color.Green)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    .pointerInput(Unit) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        awaitPointerEventScope {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            var event = awaitPointerEvent()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            event.changes[0].consumeDownChange()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            Log.d(&quot;compose_study&quot;, &quot;third layer, downChange: ${event.changes[0].consumed.downChange}&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        Log.d(&quot;compose_study&quot;, &quot;third layer Outside&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Output:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// first layer, downChange: false</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// third layer, downChange: true</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// second layer, downChange: true</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// first layer Outside</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// third layer Outside</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// second layer Outside</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_mojV" id="awaitfirstdown">awaitFirstDown<a class="hash-link" href="#awaitfirstdown" title="Direct link to heading">​</a></h3><p><code>awaitFirstDown</code> 将等待第一根手指按下事件时恢复执行，并将手指按下事件返回。分析源码我们可以发现 <code>awaitFirstDown</code> 也使用的是 <code>awaitPointerEvent</code> 实现的，默认使用 Main 模式。</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">suspend fun AwaitPointerEventScope.awaitFirstDown(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    requireUnconsumed: Boolean = true</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">): PointerInputChange {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    var event: PointerEvent</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    do {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        event = awaitPointerEvent()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } while (</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        !event.changes.fastAll {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (requireUnconsumed) it.changedToDown() else it.changedToDownIgnoreConsumed()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return event.changes[0]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_mojV" id="drag">drag<a class="hash-link" href="#drag" title="Direct link to heading">​</a></h3><p>看到 <code>drag</code> 可能很多同学疑惑为什么又是拖动。其实前面所提到的拖动类型基础API <code>detectDragGestures</code> 其内部就是使用 <code>drag</code> 而实现的。与 <code>detectDragGestures</code> 不同的是，<code>drag</code> 需要主动传入一个 <code>PointerId</code> 用以表示要具体获取到哪根手指的拖动事件。</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">suspend fun AwaitPointerEventScope.drag(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    pointerId: PointerId,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    onDrag: (PointerInputChange) -&gt; Unit</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>翻阅源码可以发现，其实 drag 内部实现最终使用的仍然还是 <code>awaitPointerEvent</code> 。这里就不具体展开看了，感兴趣的可以自己去跟源码。</p><h4 class="anchor anchorWithStickyNavbar_mojV" id="举例说明-3">举例说明<a class="hash-link" href="#举例说明-3" title="Direct link to heading">​</a></h4><p>通过结合 <code>awaitFirstDown</code> 与 <code>drag</code> 这些基础 API 我们已经可以自己实现 UI 拖动手势流程了。我们仍然以我们的绿色方块作为实例，为其添加拖动手势。</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">@Preview</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Composable</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fun BaseDragGestureDemo() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    var boxSize = 100.dp</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    var offset by remember { mutableStateOf(Offset.Zero) }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Box(contentAlignment = Alignment.Center,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        modifier = Modifier.fillMaxSize()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Box(Modifier</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            .size(boxSize)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            .offset {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                IntOffset(offset.x.roundToInt(), offset.y.roundToInt())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            .background(Color.Green)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            .pointerInput(Unit) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                forEachGesture { // 循环监听每一组事件序列</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    awaitPointerEventScope {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        var downEvent = awaitFirstDown()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        drag(downEvent.id) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            offset += it.positionChange()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><div align="center"><img src="/assets/images/drag-80a95888973e3f8aff22b90304b4086d.gif" width="50%" height="50%"></div><h3 class="anchor anchorWithStickyNavbar_mojV" id="awaitdragorcancellation">awaitDragOrCancellation<a class="hash-link" href="#awaitdragorcancellation" title="Direct link to heading">​</a></h3><p>与 <code>drag</code> 不同的是，<code>awaitDragOrCancellation</code> 负责监听单次拖动事件。当手指已经抬起或拖动事件已经被消费时会返回 null。当然我们也可以使用 <code>awaitDragOrCancellation</code> 来完成 UI 拖动手势处理流程。通过翻阅源码可以发现 <code>drag</code> 其实内部也是使用 <code>awaitDragOrCancellation</code> 进行实现的。而 <code>awaitDragOrCancellation</code> 内部仍然是 <code>awaitPointerEvent</code>。</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">@Preview</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Composable</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fun BaseDragGestureDemo() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    var boxSize = 100.dp</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    var offset by remember { mutableStateOf(Offset.Zero) }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Box(contentAlignment = Alignment.Center,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        modifier = Modifier.fillMaxSize()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Box(Modifier</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            .size(boxSize)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            .offset {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                IntOffset(offset.x.roundToInt(), offset.y.roundToInt())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            .background(Color.Green)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            .pointerInput(Unit) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                forEachGesture {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    awaitPointerEventScope {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        var downPointer = awaitFirstDown()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        while (true) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            var event = awaitDragOrCancellation(downPointer.id)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            if (event == null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                break</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            offset += event.positionChange()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_mojV" id="awaittouchsloporcancellation">awaitTouchSlopOrCancellation<a class="hash-link" href="#awaittouchsloporcancellation" title="Direct link to heading">​</a></h3><p><code>awaitTouchSlopOrCancellation</code> 用于监测当前拖动手势是否是一次有效的拖动。有效指的是当前手势滑动的欧式距离(位移)是否超过设定的阈值。若拖动手势还没有达到阈值便抬起或拖动手势事件已经被消费时将返回null，翻阅源码我们又找到了<code>awaitPointerEvent</code> ，所以说 <code>awaitPointerEvent</code> 是万物之源嘛～。</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">suspend fun AwaitPointerEventScope.awaitTouchSlopOrCancellation(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    pointerId: PointerId,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    onTouchSlopReached: (change: PointerInputChange, overSlop: Offset) -&gt; Unit</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">): PointerInputChange? {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    val touchSlop = viewConfiguration.touchSlop</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    var pointer = pointerId</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    while (true) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        val event = awaitPointerEvent()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (dragEvent.positionChangeConsumed()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else if (dragEvent.changedToUpIgnoreConsumed()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (distance &gt;= touchSlop) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>我们前面所提到的 <code>detectDragGestures</code> 其内部不仅使用了 <code>drag</code> 还使用了 <code>awaitTouchSlopOrCancellation</code> 来判断手势拖动操作。仅当监测为一次有效的拖动时，才会执行 onDragStart 回调。接下来就是使用 <code>drag</code> 来监听拖动手势，仅当 <code>drag</code> 返回 false (即在拖动过程中事件分发流程前面的组件达成定制条件消费了这次的拖动手势事件) 会执行 onDragCancel 回调，否则如果所有手指抬起正常结束则会执行 onDragEnd 回调。</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">suspend fun PointerInputScope.detectDragGestures(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    onDragStart: (Offset) -&gt; Unit = { },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    onDragEnd: () -&gt; Unit = { },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    onDragCancel: () -&gt; Unit = { },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    onDrag: (change: PointerInputChange, dragAmount: Offset) -&gt; Unit</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    forEachGesture {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        awaitPointerEventScope {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ....</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            do {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                drag = awaitTouchSlopOrCancellation(down.id) { change, over -&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    change.consumePositionChange()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    overSlop = over</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } while (drag != null &amp;&amp; !drag.positionChangeConsumed())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (drag != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                onDragStart.invoke(drag.position) // 拖动开始</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                onDrag(drag, overSlop)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    !drag(drag.id) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        onDrag(it, it.positionChange())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        it.consumePositionChange()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                ) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    onDragCancel() // 拖动取消</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    onDragEnd()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/milklabdev/jetpack-compose-book/tree/master/docs/design/gesture/customGesture.mdx" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_dcUD" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_foO9"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/docs/design/gesture/nestedScroll"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">嵌套滑动（nestedScroll）</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/docs/category/列表lists"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">列表（Lists）</div></a></div></nav></div></div><div class="col col--3"><div class="tableOfContents_cNA8 thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#使用-pointerinput-modifier" class="table-of-contents__link toc-highlight">使用 PointerInput Modifier</a><ul><li><a href="#拖动类型基础-api" class="table-of-contents__link toc-highlight">拖动类型基础 API</a></li><li><a href="#点击类型基础-api" class="table-of-contents__link toc-highlight">点击类型基础 API</a></li><li><a href="#变换类型基础-api" class="table-of-contents__link toc-highlight">变换类型基础 API</a></li><li><a href="#foreachgesture" class="table-of-contents__link toc-highlight">forEachGesture</a></li></ul></li><li><a href="#手势事件作用域-awaitpointereventscope" class="table-of-contents__link toc-highlight">手势事件作用域 awaitPointerEventScope</a><ul><li><a href="#万物之源-awaitpointerevent" class="table-of-contents__link toc-highlight">万物之源 awaitPointerEvent</a></li><li><a href="#awaitfirstdown" class="table-of-contents__link toc-highlight">awaitFirstDown</a></li><li><a href="#drag" class="table-of-contents__link toc-highlight">drag</a></li><li><a href="#awaitdragorcancellation" class="table-of-contents__link toc-highlight">awaitDragOrCancellation</a></li><li><a href="#awaittouchsloporcancellation" class="table-of-contents__link toc-highlight">awaitTouchSlopOrCancellation</a></li></ul></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">社区</div><ul class="footer__items"><li class="footer__item"><a href="https://github.com/milklabdev" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Github<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2022 Milk Lab, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.279986bd.js"></script>
<script src="/assets/js/main.387f3f8c.js"></script>
</body>
</html>