<!doctype html>
<html class="docs-version-current" lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.15">
<title data-react-helmet="true">透过 Snapshot 看重组 | 你好 Compose</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:url" content="https://jetpackcompose.cn/docs/principle/snapshot"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="透过 Snapshot 看重组 | 你好 Compose"><meta data-react-helmet="true" name="description" content="Jetpack Compose 引入了一种处理可观察状态的新方法 —— Snapshot（快照）。在 Compose 中我们通过 state 的变化来触发重组，那么请思考以下几个问题："><meta data-react-helmet="true" property="og:description" content="Jetpack Compose 引入了一种处理可观察状态的新方法 —— Snapshot（快照）。在 Compose 中我们通过 state 的变化来触发重组，那么请思考以下几个问题："><link data-react-helmet="true" rel="icon" href="/img/logo.svg"><link data-react-helmet="true" rel="canonical" href="https://jetpackcompose.cn/docs/principle/snapshot"><link data-react-helmet="true" rel="alternate" href="https://jetpackcompose.cn/docs/principle/snapshot" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://jetpackcompose.cn/docs/principle/snapshot" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.cba56bc1.css">
<link rel="preload" href="/assets/js/runtime~main.b8d28577.js" as="script">
<link rel="preload" href="/assets/js/main.4a02c241.js" as="script">
</head>
<body data-theme="light">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region"><a href="#" class="skipToContent_ZgBM">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_W2Cr themedImage--light_TfLj"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_W2Cr themedImage--dark_oUvU"></div><b class="navbar__title">Jetpack Compose 博物馆</b></a><a class="navbar__item navbar__link navbar__link--active" href="/docs/">文档</a><a class="navbar__item navbar__link" href="/docs/open-source-project/compose-douban">开源项目</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/compose-museum/jetpack-compose-book" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><div class="toggle_Pssr toggle_TdHA toggleDisabled_jDku"><div class="toggleTrack_SSoT" role="button" tabindex="-1"><div class="toggleTrackCheck_XobZ"><span class="toggleIcon_eZtF">🌜</span></div><div class="toggleTrackX_YkSC"><span class="toggleIcon_eZtF">🌞</span></div><div class="toggleTrackThumb_uRm4"></div></div><input type="checkbox" class="toggleScreenReader_JnkT" aria-label="Switch between dark and light mode"></div><div class="dsla-search-wrapper"><div class="dsla-search-field" data-tags="default,docs-default-current"></div></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docs-wrapper docs-doc-page"><div class="docPage_P2Lg"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_RiI4" type="button"></button><aside class="theme-doc-sidebar-container docSidebarContainer_rKC_"><div class="sidebar_CW9Y"><nav class="menu thin-scrollbar menu_SkdO"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/">写在开头</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link hasHref_VCh3" href="/docs/category/入门">入门</a><button aria-label="Toggle the collapsible sidebar category &#x27;入门&#x27;" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/installation">安装或更新 Android Studio</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/tutorial">初识 Jetpack Compose</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" href="/docs/elements/alertdialog">基础组件</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" href="/docs/layout/box">布局组件</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link hasHref_VCh3" href="/docs/category/设计">设计</a><button aria-label="Toggle the collapsible sidebar category &#x27;设计&#x27;" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link hasHref_VCh3" tabindex="0" href="/docs/category/动画animation">动画（Animation）</a><button aria-label="Toggle the collapsible sidebar category &#x27;动画（Animation）&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link hasHref_VCh3" tabindex="0" href="/docs/category/主题theming">主题（Theming）</a><button aria-label="Toggle the collapsible sidebar category &#x27;主题（Theming）&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link hasHref_VCh3" tabindex="0" href="/docs/category/手势gesture">手势（Gesture）</a><button aria-label="Toggle the collapsible sidebar category &#x27;手势（Gesture）&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link hasHref_VCh3" tabindex="0" href="/docs/category/列表lists">列表（Lists）</a><button aria-label="Toggle the collapsible sidebar category &#x27;列表（Lists）&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link hasHref_VCh3" tabindex="0" href="/docs/category/图形graphics">图形（Graphics）</a><button aria-label="Toggle the collapsible sidebar category &#x27;图形（Graphics）&#x27;" type="button" class="clean-btn menu__caret"></button></div></li></ul></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/resources">资源</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--active hasHref_VCh3" aria-current="page" href="/docs/category/技术原理">技术原理</a><button aria-label="Toggle the collapsible sidebar category &#x27;技术原理&#x27;" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/principle/recompositionScope">了解 Compose 的重组作用域</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/principle/snapshot">透过 Snapshot 看重组</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/principle/recomposeWorkingPrinciple">重组的工作流程</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/principle/gapBuffer">Compose 运行原理与 GapBuffer</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/principle/modifierStructure">图解 Modifier</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/principle/composeAnnotation">Compose 注解到底做了什么？</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/principle/composeRemoteImage">如何为Compose Image提供网络图片加载支持</a></li></ul></li></ul></nav></div></aside><main class="docMainContainer_TCnq"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_DM6M"><div class="docItemContainer_vinB"><article><div class="tocCollapsible_jdIR theme-doc-toc-mobile tocMobile_TmEX"><button type="button" class="clean-btn tocCollapsibleButton_Fzxq">On this page</button></div><div class="theme-doc-markdown markdown"><h1>透过Snapshot看重组</h1><p>Jetpack Compose 引入了一种处理可观察状态的新方法 —— <code>Snapshot</code>（快照）。在 Compose 中我们通过 <code>state</code> 的变化来触发重组，那么请思考以下几个问题：</p><ul><li>为什么 <code>state</code> 变化能触发重组呢？</li><li>它是如何确定重组范围呢？</li><li>只要 <code>state</code> 变化就一定会重组吗？  </li></ul><p>让我们带着问题去学习！</p><blockquote><p>本文部分例子和内容来自：<a href="https://dev.to/zachklipp/introduction-to-the-compose-snapshot-system-19cn" target="_blank" rel="noopener noreferrer">Introduction to the Compose Snapshot system</a></p></blockquote><h2 class="anchor anchorWithStickyNavbar_mojV" id="snapshot-api">Snapshot API<a class="hash-link" href="#snapshot-api" title="Direct link to heading">​</a></h2><blockquote><p>一般情况下我们不需要了解快照如何使用，这些都是框架应该做的事情，我们手动操作很可能搞出问题。所以这里只是演示快照的使用（不涉及底层实现），这样有助于理解Compose重组的机制。</p></blockquote><p><code>Snapshot</code>(快照)，简单比喻就是给所有 <code>state</code> 拍了个照，因此你能获取到拍摄之前的状态。</p><p>我们通过代码演示来看看 <code>Snapshot</code> 到底是做什么的:
首先定义一个 <code>Dog</code> 类,包含一个 <code>state</code>:</p><div class="codeBlockContainer_I0IT language-Kotlin theme-code-block"><div class="codeBlockContent_wNvx Kotlin"><pre tabindex="0" class="prism-code language-Kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">class Dog {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  var name: MutableState&lt;String&gt; = mutableStateOf(&quot;&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h2 class="anchor anchorWithStickyNavbar_mojV" id="创建快照">创建快照<a class="hash-link" href="#创建快照" title="Direct link to heading">​</a></h2><div class="codeBlockContainer_I0IT language-Kotlin theme-code-block"><div class="codeBlockContent_wNvx Kotlin"><pre tabindex="0" class="prism-code language-Kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">  val dog = Dog()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  dog.name.value = “Spot”</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  val snapshot = Snapshot.takeSnapshot()  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  dog.name.value = “Fido”</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  println(dog.name.value)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  snapshot.enter {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      println(dog.name.value)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  } </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  println(dog.name.value)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // Output:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  Fido</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  Spot</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  Fido</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><hr><ul><li><code>takeSnapshot()</code> 将<code>&quot;拍摄&quot;</code>程序中所有 <code>State</code> 值的快照，无论它们是在何处创建的</li><li><code>enter</code> 函数会把快照状态恢复并应用到函数体中</li></ul><p>因此我们看到仅在 <code>enter</code> 中是旧值。</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="可变快照">可变快照<a class="hash-link" href="#可变快照" title="Direct link to heading">​</a></h2><p>我们尝试在 <code>enter</code> 块中更改狗狗的名字：</p><div class="codeBlockContainer_I0IT language-Kotlin theme-code-block"><div class="codeBlockContent_wNvx Kotlin"><pre tabindex="0" class="prism-code language-Kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">fun main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  val dog = Dog()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  dog.name.value = &quot;Spot&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  val snapshot = Snapshot.takeSnapshot()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  println(dog.name.value)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  snapshot.enter {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println(dog.name.value)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    dog.name.value = &quot;Fido&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println(dog.name.value)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  println(dog.name.value)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Output:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Spot</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Spot</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">java.lang.IllegalStateException: Cannot modify a state object in a read-only snapshot</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>会发现当我们尝试修改值时报错了，因为 <code>takeSnapshot()</code> 是只读的,因此在 <code>enter</code> 内部我们可以读但不能写，如果想要创建一个可变快照应使用 <code>takeMutableSnapshot()</code> 方法。</p><div class="codeBlockContainer_I0IT language-Kotlin theme-code-block"><div class="codeBlockContent_wNvx Kotlin"><pre tabindex="0" class="prism-code language-Kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">fun main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  val dog = Dog()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  dog.name.value = &quot;Spot&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  val snapshot = Snapshot.takeMutableSnapshot()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  println(dog.name.value)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  snapshot.enter {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    dog.name.value = &quot;Fido&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println(dog.name.value)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  println(dog.name.value)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Output:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Spot</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Fido</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Spot </span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>可以看到程序没有崩溃了，但是在 <code>enter</code> 里的操作并没有在其范围之外生效！这是一个很重要的隔离机制，如果我们想要应用 <code>enter</code> 内部的变更需要调用 <code>apply()</code> 方法：  </p><div class="codeBlockContainer_I0IT language-Kotlin theme-code-block"><div class="codeBlockContent_wNvx Kotlin"><pre tabindex="0" class="prism-code language-Kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain"> fun main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  val dog = Dog()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  dog.name.value = &quot;Spot&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  val snapshot = Snapshot.takeMutableSnapshot()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  println(dog.name.value)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  snapshot.enter {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    dog.name.value = &quot;Fido&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println(dog.name.value)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  println(dog.name.value)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  snapshot.apply()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  println(dog.name.value)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Output:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Spot</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Fido</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Spot</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Fido </span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>可以看到调用 <code>apply</code> 之后，新值在 <code>enter</code> 之外也生效了。我们还可以使 <code>Snapshot.withMutableSnapshot()</code> 来简化调用：</p><div class="codeBlockContainer_I0IT language-Kotlin theme-code-block"><div class="codeBlockContent_wNvx Kotlin"><pre tabindex="0" class="prism-code language-Kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">fun main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  val dog = Dog()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  dog.name.value = &quot;Spot&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  Snapshot.withMutableSnapshot {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println(dog.name.value)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    dog.name.value = &quot;Fido&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println(dog.name.value)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  println(dog.name.value)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>到目前为止我们知道了：</p><ul><li>拍摄我们所有状态的快照</li><li>“恢复”状态到特定的代码块</li><li>改变状态值</li></ul><p>但我们还不知道如何感知读写，接下来让我们搞清楚这个。</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="观察读取和写入">观察读取和写入<a class="hash-link" href="#观察读取和写入" title="Direct link to heading">​</a></h2><p>无论是 <code>LiveData</code>,<code>Flow</code> 还是 <code>State</code> 都是观察者模式，那么就要有观察者和被观察者。对于快照系统，被观察者就是我们的 <code>state</code>，而观察者有两个，一个是读取观察者，一个是写入观察者。</p><p>实际上 <code>takeMutableSnapshot</code>有两个可选参数的，分别在读和写时回调：</p><div class="codeBlockContainer_I0IT language-Kotlin theme-code-block"><div class="codeBlockContent_wNvx Kotlin"><pre tabindex="0" class="prism-code language-Kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain"> fun takeMutableSnapshot(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            readObserver: ((Any) -&gt; Unit)? = null,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            writeObserver: ((Any) -&gt; Unit)? = null</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ): MutableSnapshot =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            (currentSnapshot() as? MutableSnapshot)?.takeNestedMutableSnapshot(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                readObserver,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                writeObserver</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ) ?: error(&quot;Cannot create a mutable snapshot of an read-only snapshot&quot;)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>因此我们可以在回调中执行一些操作,在 <code>Compose</code> 中就是值读取时记录 <code>ComposeScope</code>,写入时如果有变化则将对应的 <code>Scope</code> 标记为 <code>invalid</code>。</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="全局快照">全局快照<a class="hash-link" href="#全局快照" title="Direct link to heading">​</a></h2><p>全局快照是位于快照树根部的可变快照。与必须 <code>apply</code> 才能生效的常规可变快照相比，全局快照没有 <code>apply</code> 操作。比如我们会在 <code>ViewModel</code> 里定义 <code>state</code>,并且在 <code>repository</code>请求数据并给 <code>state</code> 赋值。此时就会由 GlobalSnapshot 去发送通知：</p><p>它通过调用：</p><ul><li><code>Snapshot.notifyObjectsInitialized</code>。这会为自上次调用以来更改的任何状态发送通知。</li><li><code>Snapshot.sendApplyNotifications()</code>。这类似于 notifyObjectsInitialized，但只有在实际发生更改时才会推进快照。在第一种情况下，只要将任何可变快照应用于全局快照，就会隐式调用此函数。</li></ul><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">internal object GlobalSnapshotManager {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private val started = AtomicBoolean(false)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fun ensureStarted() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (started.compareAndSet(false, true)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            val channel = Channel&lt;Unit&gt;(Channel.CONFLATED)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            CoroutineScope(AndroidUiDispatcher.Main).launch {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                channel.consumeEach {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    Snapshot.sendApplyNotifications()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Snapshot.registerGlobalWriteObserver {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                channel.offer(Unit)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>可以看到在 <code>android</code> 平台上注册了 <code>writeObserver</code>,它还有 <code>ApplyObserver</code> 我们后面再说。</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="多线程">多线程<a class="hash-link" href="#多线程" title="Direct link to heading">​</a></h2><p>在给定线程的快照中，在应用该快照之前，不会看到其他线程对状态值所做的更改。快照与其他快照“隔离”。在应用快照并自动推进全局快照之前，对快照内的状态所做的任何更改对其他线程都将不可见。
看这个类名大家就懂了 <code>SnapshotThreadLocal</code>:</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">internal actual class SnapshotThreadLocal&lt;T&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private val map = AtomicReference&lt;ThreadMap&gt;(emptyThreadMap)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private val writeMutex = Any()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Suppress(&quot;UNCHECKED_CAST&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    actual fun get(): T? = map.get().get(Thread.currentThread().id) as T?</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    actual fun set(value: T?) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        val key = Thread.currentThread().id</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        synchronized(writeMutex) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            val current = map.get()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (current.trySet(key, value)) return</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            map.set(current.newWith(key, value))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h2 class="anchor anchorWithStickyNavbar_mojV" id="冲突">冲突<a class="hash-link" href="#冲突" title="Direct link to heading">​</a></h2><p>如果我们&quot;拍摄&quot;了多个快照并且均应用修改会怎样呢？</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">fun main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  val dog = Dog()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  dog.name.value = &quot;Spot&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  val snapshot1 = Snapshot.takeMutableSnapshot()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  val snapshot2 = Snapshot.takeMutableSnapshot()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  println(dog.name.value)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  snapshot1.enter {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    dog.name.value = &quot;Fido&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println(&quot;in snapshot1: &quot; + dog.name.value)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // Don’t apply it yet, let’s try setting a third value first.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  println(dog.name.value)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  snapshot2.enter {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    dog.name.value = &quot;Fluffy&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println(&quot;in snapshot2: &quot; + dog.name.value)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // Ok now we can apply both.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  println(&quot;before applying: &quot; + dog.name.value)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  snapshot1.apply()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  println(&quot;after applying 1: &quot; + dog.name.value)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  snapshot2.apply()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  println(&quot;after applying 2: &quot; + dog.name.value)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Output:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Spot</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">in snapshot1: Fido</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Spot</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">in snapshot2: Fluffy</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">before applying: Spot</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">after applying 1: Fido</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">after applying 2: Fido</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>会发现第二个快照的更改无法应用，因为它们都视图以相同的初始值进行修改，因此第二个快照要么再执行一次 <code>enter</code>，要么告诉如何解冲突。  </p><p>Compose 实际上有一个用于解决合并冲突的 API！<code>mutableStateOf()</code> 需要一个可选的 <code>SnapshotMutationPolicy</code>. 该策略定义了如何比较特定类型的值 (equivalent) 以及如何解决冲突 (merge)。并且提供了一些开箱即用的策略：</p><ul><li><code>structuralEqualityPolicy</code>– 使用对象的 <code>equals</code> 方法 ( ==)比较对象，所有写入都被认为是非冲突的。</li><li><code>referentialEqualityPolicy</code>– 通过引用 ( ===)比较对象，所有写入都被认为是非冲突的。</li><li><code>neverEqualPolicy</code>– 将所有对象视为不相等，所有写入都被认为是非冲突的。</li></ul><p>我们也可以构建自己的规则：</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">class Dog {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  var name: MutableState&lt;String&gt; =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mutableStateOf(&quot;&quot;, policy = object : SnapshotMutationPolicy&lt;String&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      override fun equivalent(a: String, b: String): Boolean = a == b</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      override fun merge(previous: String, current: String, applied: String): String =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        &quot;$applied, briefly known as $current, originally known as $previous&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    })</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fun main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // Same as before.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Output:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Spot</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">in snapshot1: Fido</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Spot</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">in snapshot2: Fluffy</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">before applying: Spot</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">after applying 1: Fido</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">after applying 2: Fluffy, briefly known as Fido, originally known as Spot</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h2 class="anchor anchorWithStickyNavbar_mojV" id="总结">总结<a class="hash-link" href="#总结" title="Direct link to heading">​</a></h2><p>以上就是 <code>Snapshot</code> (快照)的基本使用,它就相当于高级的 DiffUtil。它的特点总结起来就是：</p><ul><li>响应式：有状态的代码始终自动保持最新。我们无需担心订阅和反订阅。</li><li>隔离性：有状态代码可以对状态进行操作，而不必担心在不同线程上运行的代码会改变该状态。<code>Compose</code> 可以利用这一点来实现旧的 <code>View</code> 系统无法实现的效果，例如将重构放到多个后台线程上去执行。</li></ul><h2 class="anchor anchorWithStickyNavbar_mojV" id="解惑">解惑<a class="hash-link" href="#解惑" title="Direct link to heading">​</a></h2><ul><li><strong>为什么<code>state</code>变化能触发重组呢？</strong><blockquote><p>Jetpack Compose在执行时注册了 <code>readObserverOf</code> 和<code>writeObserverOf</code> :</p></blockquote></li></ul><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain"> private inline fun &lt;T&gt; composing(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        composition: ControlledComposition,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        modifiedValues: IdentityArraySet&lt;Any&gt;?,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        block: () -&gt; T</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ): T {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        val snapshot = Snapshot.takeMutableSnapshot(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            readObserverOf(composition), writeObserverOf(composition, modifiedValues)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return snapshot.enter(block)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } finally {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            applyAndCheck(snapshot)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>其中在读取状态的地方会执行：</p><ul><li><code>readObserverOf</code> 来记录哪些 <code>scope 使用了此 </code>state` :</li></ul><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain"> override fun recordReadOf(value: Any) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (!areChildrenComposing) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            composer.currentRecomposeScope?.let {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                it.used = true</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                observations.add(value, it)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><ul><li><code>writeObserverOf</code>
而写入时会找出对应使用此 <code>state</code> 的 <code>scope</code> 使其 <code>invalidate</code> :</li></ul><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain"> override fun recordWriteOf(value: Any) = synchronized(lock) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        invalidateScopeOfLocked(value)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        derivedStates.forEachScopeOf(value) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            invalidateScopeOfLocked(it)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  private fun invalidateScopeOfLocked(value: Any) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          observations.forEachScopeOf(value) { scope -&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (scope.invalidateForResult(value) == InvalidationResult.IMMINENT) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                observationsProcessed.add(value, scope)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>在下次帧信号到达时对于这些<code>scope</code>执行重组。</p><ul><li><strong>它是如何确定重组范围呢？</strong></li></ul><blockquote><p>能够被标记为 Invalid 的代码必须是非 inline 且无返回值的 @Composalbe function/lambda，必须遵循 重组范围最小化 原则。
详细参见：<a href="/docs/principle/recompositionScope/">Compose 如何确定重组范围</a></p></blockquote><ul><li><strong>只要 <code>state</code> 变化就一定会重组吗？</strong><br>不一定，具体案例请看以下例子：</li></ul><h3 class="anchor anchorWithStickyNavbar_mojV" id="1-例子">1. 例子①<a class="hash-link" href="#1-例子" title="Direct link to heading">​</a></h3><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">    val darkMode = mutableStateOf(&quot;hello&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    override fun onCreate(savedInstanceState: Bundle?) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        super.onCreate(savedInstanceState)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        setContent {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            lifecycleScope.launch {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                delay(100)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                val text= darkMode.value</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                darkMode.value = &quot;Compose&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>不会重组，因为 <code>delay</code> 导致状态的读取是在 <code>snap.apply</code> 方法之外执行的,
因此也就不会注册 <code>readObserverOf</code> ,自然也就不会与 <code>composeScope</code> 挂钩，也就不会触发重组，在这个例子里如果是在 <code>delay</code> 之前读取则会重组。</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="2-例子">2. 例子②<a class="hash-link" href="#2-例子" title="Direct link to heading">​</a></h3><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">   val darkMode = mutableStateOf(&quot;hello&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    override fun onCreate(savedInstanceState: Bundle?) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        super.onCreate(savedInstanceState)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        setContent {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            thread {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                val text =  darkMode.value</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                darkMode.value = &quot;Compose&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p><code>thread</code> 中的<code>state</code>在不同线程读取，由于<code>SnapshotThreadLocal</code>机制，如果此线程无快照，则获取<code>GlobalSnapshot</code>：</p><div class="codeBlockContainer_I0IT theme-code-block"><div class="codeBlockContent_wNvx"><pre tabindex="0" class="prism-code language-text codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">internal fun currentSnapshot(): Snapshot =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    threadSnapshot.get() ?: currentGlobalSnapshot.get()</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>由于没有对应的<code>readObserver</code>,因此此例子不会重组。但是如果在<code>composable</code>内读取了此<code>state</code>是会重组的，因为<code>ReComposer</code>注册了<code>ApplyObserver</code>,在<code>apply</code>时也会对<code>globalModified</code>进行记录，在下一帧信号到达时去查找对应的<code>scope</code>（大家可以断点跟一下流程）：</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain"> val unregisterApplyObserver = Snapshot.registerApplyObserver { changed, _ -&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                synchronized(stateLock) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    if (_state.value &gt;= State.Idle) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        snapshotInvalidations += changed</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        deriveStateLocked()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    } else null</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }?.resume(Unit)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_mojV" id="3-例子">3. 例子③<a class="hash-link" href="#3-例子" title="Direct link to heading">​</a></h3><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">override fun onCreate(savedInstanceState: Bundle?) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        super.onCreate(savedInstanceState)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        setContent {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            val darkMode = mutableStateOf(&quot;hello&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Text(darkMode.value)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            darkMode.value = &quot;Compose&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>这个也没触发重组，可能大家会疑惑，这个没异步，断点也有 <code>readObserver</code> 和 <code>writeObserver</code> 为啥不会触发重组呢？  不是说状态变更会将使用它的 <code>scope</code> 记为 <code>invalid</code> 吗？</p><p>然而实际运行中，<code>InvalidationResult</code>为<code>IGNORE</code></p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain"> fun invalidate(scope: RecomposeScopeImpl, instance: Any?): InvalidationResult {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (anchor == null || !slotTable.ownsAnchor(anchor) || !anchor.valid)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // The scope has not yet entered the composition</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return InvalidationResult.IGNORED </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>首先我们确实记录下了使用 <code>state</code> 的 <code>scope</code>,不然也不会在修改时触发 <code>invalidate</code> 行为。但此时 <code>slotTable</code> 里并还没有可重组的区域锚点信息，只有在组合完成之后才能拿到每个区域的锚点<code> anchors</code>。
简单描述就是 <code>Compose</code> 使用 <code>SlotTable</code> 来记录数据信息，此时第一次完整的组合都没完成，不知道该从哪下手。  </p><blockquote><p>有关 <code>SlotTable</code> 的更多信息请参阅：<a href="https://juejin.cn/post/6889797083667267598" target="_blank" rel="noopener noreferrer">深入详解JetpackCompose|实现原理</a></p></blockquote><p>其次就是由于 <code>state</code> 的创建是在 <code>enter</code> 代码块中，此时 <code>state.snapshotId</code>==<code>Snapshot.id</code> ,并不会记录 <code>state</code> 的变化。毕竟快照的 <code>diff</code> 是作用在两个快照之间。</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">internal fun &lt;T : StateRecord&gt; T.overwritableRecord(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    state: StateObject,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    snapshot: Snapshot,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    candidate: T</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">): T {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    val id = snapshot.id</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //此时直接返回，并没有记录state变化</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (candidate.snapshotId == id) return candidate</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>但是如果你把 <code>state</code> 的创建放到 <code>setContent</code> 之外呢？</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="4-例子">4. 例子④<a class="hash-link" href="#4-例子" title="Direct link to heading">​</a></h3><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">  val darkMode = mutableStateOf(&quot;hello&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    override fun onCreate(savedInstanceState: Bundle?) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        super.onCreate(savedInstanceState)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        setContent {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Text(darkMode.value)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            darkMode.value = &quot;Compose&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p><strong>答案是会重组</strong>  </p><p>因为这个状态是在拍摄之前创建的，此时 <code>state.snapshotId</code>!=<code>Snapshot.id</code>,此期间对 <code>state</code> 的修改虽然不会立即标记为 <code>invalid</code> ,但是会计入  <code>modified</code> , <code>apply</code> 之后，由全局快照进行通知:</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">internal fun &lt;T : StateRecord&gt; T.overwritableRecord(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    state: StateObject,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    snapshot: Snapshot,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    candidate: T</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">): T {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    val id = snapshot.id</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (candidate.snapshotId == id) return candidate</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    val newData = newOverwritableRecord(state, snapshot)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    newData.snapshotId = id</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   //记录变化</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    snapshot.recordModified(state)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return newData</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>会在 <code>apply</code> 时通知到观察者 <code>ApplyObserver</code>（刚才还提到 writerObserver ），记录下 <code>changed</code>:</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">val unregisterApplyObserver = Snapshot.registerApplyObserver { changed, _ -&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                synchronized(stateLock) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    if (_state.value &gt;= State.Idle) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        // here</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        snapshotInvalidations += changed</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        deriveStateLocked()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    } else null</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }?.resume(Unit)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p><code>composation</code> 则会找出观察了对应变化状态的 <code>scope</code> 标记为 <code>invalid</code> 等待重组：  </p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain"> private fun addPendingInvalidationsLocked(values: Set&lt;Any&gt;) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        var invalidated: HashSet&lt;RecomposeScopeImpl&gt;? = null</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fun invalidate(value: Any) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            observations.forEachScopeOf(value) { scope -&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    !observationsProcessed.remove(value, scope) &amp;&amp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    scope.invalidateForResult(value) != InvalidationResult.IGNORED</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                ) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    val set = invalidated</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        ?: HashSet&lt;RecomposeScopeImpl&gt;().also {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            invalidated = it</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    set.add(scope)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (value in values) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (value is RecomposeScopeImpl) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                value.invalidateForResult(null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                invalidate(value)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                derivedStates.forEachScopeOf(value) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    invalidate(it)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        invalidated?.let {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            observations.removeValueIf { scope -&gt; scope in it }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_mojV" id="5-例子">5. 例子⑤<a class="hash-link" href="#5-例子" title="Direct link to heading">​</a></h3><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">var onlyDisplay = mutableStateOf(&quot;onlyDisplay&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class MainActivity : ComponentActivity() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    override fun onCreate(savedInstanceState: Bundle?) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        super.onCreate(savedInstanceState)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        setContent {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Text(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                text = onlyDisplay.value,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                fontSize = 50.sp,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            onlyDisplay.value = &quot;Display&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>如果把 <code>state</code> 声明放到 <code>kt</code> 文件最外层，是否会重组？</p><p>答案是不会，因为在 <code>kotlin</code> 中如果把变量不放到类里，直接放到文件顶层。编译之后其实会生成一个文件，而这个属性则变成 <code>static</code> 的。</p><div class="codeBlockContainer_I0IT language-java theme-code-block"><div class="codeBlockContent_wNvx java"><pre tabindex="0" class="prism-code language-java codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">public final class MainActivityKt {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       static MutableState&lt;String&gt; onlyDisplay = SnapshotStateKt.mutableStateOf$default(&quot;onlyDisplay&quot;, null, 2, null);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>因此这个例子就涉及了类的初始化问题：</p><blockquote><h2 class="anchor anchorWithStickyNavbar_mojV" id="只有主动请求一个类这个类才会初始化仅包含静态变量函数等静态的东西">只有主动请求一个类,这个类才会初始化,仅包含静态变量,函数,等静态的东西.<a class="hash-link" href="#只有主动请求一个类这个类才会初始化仅包含静态变量函数等静态的东西" title="Direct link to heading">​</a></h2><p>也就是说在这个例子里只有在调用 <code>onlyDisplay</code> 时，才执行初始化，所以其 <code>state.snapshotId==snapshot.Id</code> ,此时首次组合尚未执行完毕，本次的 <code>invalidateResult==IGNORE</code>，也不会记为 <code>modified</code>，就和例子③ 一样的问题了。</p></blockquote><hr><blockquote><p>以上就是快照系统的使用和<code> Jetpack Compose</code> 重组的机制，有任何不正确的地方欢迎指正。</p></blockquote></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/compose-museum/jetpack-compose-book/tree/master/docs/principle/snapshot.mdx" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_dcUD" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_foO9"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/docs/principle/recompositionScope"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">了解 Compose 的重组作用域</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/docs/principle/recomposeWorkingPrinciple"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">重组的工作流程</div></a></div></nav></div></div><div class="col col--3"><div class="tableOfContents_cNA8 thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#snapshot-api" class="table-of-contents__link toc-highlight">Snapshot API</a></li><li><a href="#创建快照" class="table-of-contents__link toc-highlight">创建快照</a></li><li><a href="#可变快照" class="table-of-contents__link toc-highlight">可变快照</a></li><li><a href="#观察读取和写入" class="table-of-contents__link toc-highlight">观察读取和写入</a></li><li><a href="#全局快照" class="table-of-contents__link toc-highlight">全局快照</a></li><li><a href="#多线程" class="table-of-contents__link toc-highlight">多线程</a></li><li><a href="#冲突" class="table-of-contents__link toc-highlight">冲突</a></li><li><a href="#总结" class="table-of-contents__link toc-highlight">总结</a></li><li><a href="#解惑" class="table-of-contents__link toc-highlight">解惑</a><ul><li><a href="#1-例子" class="table-of-contents__link toc-highlight">1. 例子①</a></li><li><a href="#2-例子" class="table-of-contents__link toc-highlight">2. 例子②</a></li><li><a href="#3-例子" class="table-of-contents__link toc-highlight">3. 例子③</a></li><li><a href="#4-例子" class="table-of-contents__link toc-highlight">4. 例子④</a></li><li><a href="#5-例子" class="table-of-contents__link toc-highlight">5. 例子⑤</a></li></ul></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">社区</div><ul class="footer__items"><li class="footer__item"><a href="https://github.com/compose-museum" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Github<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2022 Jetpack Compose 博物馆, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.b8d28577.js"></script>
<script src="/assets/js/main.4a02c241.js"></script>
</body>
</html>