<!doctype html>
<html class="docs-version-current" lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.15">
<title data-react-helmet="true">如何为Compose Image提供网络图片加载支持 | 你好 Compose</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:url" content="https://jetpackcompose.cn/docs/principle/composeRemoteImage"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="如何为Compose Image提供网络图片加载支持 | 你好 Compose"><meta data-react-helmet="true" name="description" content="前言"><meta data-react-helmet="true" property="og:description" content="前言"><link data-react-helmet="true" rel="icon" href="/img/logo.svg"><link data-react-helmet="true" rel="canonical" href="https://jetpackcompose.cn/docs/principle/composeRemoteImage"><link data-react-helmet="true" rel="alternate" href="https://jetpackcompose.cn/docs/principle/composeRemoteImage" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://jetpackcompose.cn/docs/principle/composeRemoteImage" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.cba56bc1.css">
<link rel="preload" href="/assets/js/runtime~main.ae8d57c9.js" as="script">
<link rel="preload" href="/assets/js/main.50fd7d2b.js" as="script">
</head>
<body data-theme="light">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region"><a href="#" class="skipToContent_ZgBM">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_W2Cr themedImage--light_TfLj"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_W2Cr themedImage--dark_oUvU"></div><b class="navbar__title">Jetpack Compose 博物馆</b></a><a class="navbar__item navbar__link navbar__link--active" href="/docs/">文档</a><a class="navbar__item navbar__link" href="/docs/open-source-project/compose-douban">开源项目</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/compose-museum/jetpack-compose-book" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><div class="toggle_Pssr toggle_TdHA toggleDisabled_jDku"><div class="toggleTrack_SSoT" role="button" tabindex="-1"><div class="toggleTrackCheck_XobZ"><span class="toggleIcon_eZtF">🌜</span></div><div class="toggleTrackX_YkSC"><span class="toggleIcon_eZtF">🌞</span></div><div class="toggleTrackThumb_uRm4"></div></div><input type="checkbox" class="toggleScreenReader_JnkT" aria-label="Switch between dark and light mode"></div><div class="dsla-search-wrapper"><div class="dsla-search-field" data-tags="default,docs-default-current"></div></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docs-wrapper docs-doc-page"><div class="docPage_P2Lg"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_RiI4" type="button"></button><aside class="theme-doc-sidebar-container docSidebarContainer_rKC_"><div class="sidebar_CW9Y"><nav class="menu thin-scrollbar menu_SkdO"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/">写在开头</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link hasHref_VCh3" href="/docs/category/入门">入门</a><button aria-label="Toggle the collapsible sidebar category &#x27;入门&#x27;" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/installation">安装或更新 Android Studio</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/tutorial">初识 Jetpack Compose</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" href="/docs/elements/alertdialog">基础组件</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" href="/docs/layout/box">布局组件</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link hasHref_VCh3" href="/docs/category/设计">设计</a><button aria-label="Toggle the collapsible sidebar category &#x27;设计&#x27;" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link hasHref_VCh3" tabindex="0" href="/docs/category/动画animation">动画（Animation）</a><button aria-label="Toggle the collapsible sidebar category &#x27;动画（Animation）&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link hasHref_VCh3" tabindex="0" href="/docs/category/主题theming">主题（Theming）</a><button aria-label="Toggle the collapsible sidebar category &#x27;主题（Theming）&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link hasHref_VCh3" tabindex="0" href="/docs/category/手势gesture">手势（Gesture）</a><button aria-label="Toggle the collapsible sidebar category &#x27;手势（Gesture）&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link hasHref_VCh3" tabindex="0" href="/docs/category/列表lists">列表（Lists）</a><button aria-label="Toggle the collapsible sidebar category &#x27;列表（Lists）&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link hasHref_VCh3" tabindex="0" href="/docs/category/图形graphics">图形（Graphics）</a><button aria-label="Toggle the collapsible sidebar category &#x27;图形（Graphics）&#x27;" type="button" class="clean-btn menu__caret"></button></div></li></ul></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/resources">资源</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--active hasHref_VCh3" aria-current="page" href="/docs/category/技术原理">技术原理</a><button aria-label="Toggle the collapsible sidebar category &#x27;技术原理&#x27;" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/principle/recompositionScope">了解 Compose 的重组作用域</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/principle/snapshot">透过 Snapshot 看重组</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/principle/recomposeWorkingPrinciple">重组的工作流程</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/principle/gapBuffer">Compose 运行原理与 GapBuffer</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/principle/modifierStructure">图解 Modifier</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/principle/composeAnnotation">Compose 注解到底做了什么？</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/principle/composeRemoteImage">如何为Compose Image提供网络图片加载支持</a></li></ul></li></ul></nav></div></aside><main class="docMainContainer_TCnq"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_DM6M"><div class="docItemContainer_vinB"><article><div class="tocCollapsible_jdIR theme-doc-toc-mobile tocMobile_TmEX"><button type="button" class="clean-btn tocCollapsibleButton_Fzxq">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>如何为Compose Image提供网络图片加载支持</h1></header><h2 class="anchor anchorWithStickyNavbar_mojV" id="前言">前言<a class="hash-link" href="#前言" title="Direct link to heading">​</a></h2><p>如何为Compose Image提供网络图片加载支持？目前（Compose 1.0.5）最好的选择是使用图片框架Coil，Coil对Jetpack Compose相关的支持文档<a href="https://coil-kt.github.io/coil/compose/" target="_blank" rel="noopener noreferrer">在这</a>。</p><p>Compose内的Image组件类似于ImageView，仅支持从本地加载图片资源，要想从网络中获取图片并加载，我们首先就得要使用能够处理网络请求的框架，将远程图片资源载入到本地才行。目前主流的图片加载框架Picasso、Glide、Coil等，它们更多面对的仍是传统的View系统下，将图片加载到ImageView中并显示这样的应用场景，而不是为Compose量身打造的，基于此，Accompanist库曾提供了一些图片加载框架的扩展库，为Compose的Image显示网络图片进行简便支持。时过境迁，后来Coil为Image加载图片提供了相关支持，故Accompanist以前关于图片加载框架扩展的依赖都被废弃并不推荐使用了。（Picasso可能在长期内都不会支持Compose Image，<a href="https://github.com/square/picasso/issues/2203" target="_blank" rel="noopener noreferrer">详情</a>）</p><p>接下来我们将分析Accompanist曾经是如何对图片框架做扩展适配，使之能够与Compose配合工作的。</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="picassoin-version-062">Picasso(in version 0.6.2)<a class="hash-link" href="#picassoin-version-062" title="Direct link to heading">​</a></h2><p>Accompanist在0.3.0版本就提供了Picasso的支持，不过，在版本0.7.0该集成被移除（相关的pull参见<a href="https://github.com/google/accompanist/pull/253" target="_blank" rel="noopener noreferrer">https://github.com/google/accompanist/pull/253</a>）</p><p>在0.6.2版本中，想要加载网络图片，你可能会使用如下代码：</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">PicassoImage(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    data = &quot;http://...&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    modifier = Modifier.size(50.dp),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">) { imageLoadState -&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    when(imageLoadState) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">CoilImage(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    data = &quot;https://i.imgur.com/StXm8nf.jpg&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    contentDescription = null,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    onRequestCompleted = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println(&quot;LoadingCoilImage onRequestCompleted $it&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    contentScale = ContentScale.Crop,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    modifier = Modifier.fillMaxWidth(),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>在version 0.6.2中，加载远程图片的方法是使用专用的<code>Image</code>组件，使用Picasso框架的调用<code>PicassoImage</code>，使用Coil的则调用<code>CoilImage</code>，等等。它们都依赖于一个imageloader-core的核心库来进行图片加载，我们不难想象这个加载图片的方法，为了糅合各类框架，肯定要用不少泛型，事实上它长下面这样：</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">@Composable</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fun &lt;R : Any, TR : Any&gt; ImageLoad(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    request: R,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    executeRequest: suspend (TR) -&gt; ImageLoadState,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    modifier: Modifier = Modifier,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    requestKey: Any = request,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    transformRequestForSize: (R, IntSize) -&gt; TR?,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    shouldRefetchOnSizeChange: (currentResult: ImageLoadState, size: IntSize) -&gt; Boolean = DefaultRefetchOnSizeChangeLambda,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    onRequestCompleted: (ImageLoadState) -&gt; Unit = EmptyRequestCompleteLambda,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    content: @Composable BoxScope.(imageLoadState: ImageLoadState) -&gt; Unit</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>泛型R代表请求的值，这个值之所以是泛型，是因为实际上各种框架都支持多类型的图片加载请求，这个请求可能是基于一个URL的String，也可能单纯是一个resource的id，或者就是一个<code>Bitmap</code>，等等。泛型TR代表了不同图片框架内收集本次图片请求信息的实体类（或者是Builder），在Picasso中这个类叫<code>RequestCreator</code>，在Glide中这个类叫<code>RequestBuilder</code>。</p><p>我们继续观察它的实现：</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">@Composable</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fun &lt;R : Any, TR : Any&gt; ImageLoad(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    request: R,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    executeRequest: suspend (TR) -&gt; ImageLoadState,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    modifier: Modifier = Modifier,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    requestKey: Any = request,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    transformRequestForSize: (R, IntSize) -&gt; TR?,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    shouldRefetchOnSizeChange: (currentResult: ImageLoadState, size: IntSize) -&gt; Boolean = DefaultRefetchOnSizeChangeLambda,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    onRequestCompleted: (ImageLoadState) -&gt; Unit = EmptyRequestCompleteLambda,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    content: @Composable BoxScope.(imageLoadState: ImageLoadState) -&gt; Unit</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 三个rememberUpdatedState，目的是为了避免更改后重组</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    val updatedOnRequestCompleted by rememberUpdatedState(onRequestCompleted)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    val updatedTransformRequestForSize by rememberUpdatedState(transformRequestForSize)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    val updatedExecuteRequest by rememberUpdatedState(executeRequest)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 这个state拿来缓存控件大小，因为控件大小要等到Compose内容传入constraints才能确定</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    var requestSize by remember(requestKey) { mutableStateOf&lt;IntSize?&gt;(null) }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 重点，这里使用produceState将executeRequest返回的非Compose状态转换为一个State</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 之所以连加载图片的过程都抽象成一个叫executeRequest的lambda，还是因为要糅合多个框架</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    val loadState by produceState&lt;ImageLoadState&gt;(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        initialValue = ImageLoadState.Loading,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        key1 = requestKey,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        key2 = requestSize,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // value一开始肯定被赋值为ImageLoadState.Loading，因为requestSize为空。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 当requestSize被赋值后，首先将开始执行transformRequestForSize这个lambda</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 传入原来的request和新获得的size，要求返回一个类似RequestBuilder的结果</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        value = requestSize?.let { updatedTransformRequestForSize(request, it) }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ?.let { transformedRequest -&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                   // 这里传入刚才的RequestBuilder</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 发起图片加载请求，这里可能会挂起</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    updatedExecuteRequest(transformedRequest)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                } catch (e: CancellationException) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // We specifically don&#x27;t do anything for the request coroutine being</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // cancelled: https://github.com/google/accompanist/issues/217</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 如果我们响应了协程的CancellationException，让ImageLoadState变成了Error</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 有可能会出问题，因为如果取消的协程在新协程完成后执行，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 会导致新的图片状态（Success）被上次取消的结果（Error）覆盖</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    throw e</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                } catch (e: Error) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // Re-throw all Errors</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    throw e</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                } catch (e: IllegalStateException) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // Re-throw all IllegalStateExceptions</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    throw e</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                } catch (t: Throwable) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // Anything else, we wrap in a Error state instance</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 除了CancellationException、Error、IllegalStateException之外，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 其余的错误将会令状态转变为Error</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    ImageLoadState.Error(painter = null, throwable = t)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // also内，加载完成，回调onRequestCompleted</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }.also(updatedOnRequestCompleted)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } ?: ImageLoadState.Loading</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    BoxWithConstraints(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        modifier = modifier,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        propagateMinConstraints = true,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        val size = IntSize(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            width = if (constraints.hasBoundedWidth) constraints.maxWidth else -1,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            height = if (constraints.hasBoundedHeight) constraints.maxHeight else -1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (requestSize == null ||</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            (requestSize != size &amp;&amp; shouldRefetchOnSizeChange(loadState, size))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            requestSize = size</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        content(loadState)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p><code>ImageLoad</code>的思路清晰明了：调用方告诉它如何build一个请求，并在使用图片框架的过程中产生<code>ImageLoadState</code>状态，它会把<code>ImageLoadState</code>转换为可以观察的<code>State&lt;ImageLoadState&gt;</code>。</p><p>直接使用通用实现的缺点在于会产生很多模板代码，可以基于通用实现进行更简洁的封装，我们以特定的<code>PicassoImage</code>的实现为例进行分析：</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">// 这个API封装更彻底，不需要写when(state)，直接在函数中传入error、loading的内容即可</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Composable</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fun PicassoImage(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    data: Any,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    contentDescription: String?,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    modifier: Modifier = Modifier,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    alignment: Alignment = Alignment.Center,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    contentScale: ContentScale = ContentScale.Fit,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    colorFilter: ColorFilter? = null,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fadeIn: Boolean = false,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    picasso: Picasso = LocalPicasso.current,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    requestBuilder: (RequestCreator.(size: IntSize) -&gt; RequestCreator)? = null,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    shouldRefetchOnSizeChange: (currentResult: ImageLoadState, size: IntSize) -&gt; Boolean = DefaultRefetchOnSizeChangeLambda,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    onRequestCompleted: (ImageLoadState) -&gt; Unit = EmptyRequestCompleteLambda,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    error: @Composable (BoxScope.(ImageLoadState.Error) -&gt; Unit)? = null,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    loading: @Composable (BoxScope.() -&gt; Unit)? = null,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    PicassoImage(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        data = data,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        modifier = modifier,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        requestBuilder = requestBuilder,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        picasso = picasso,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        shouldRefetchOnSizeChange = shouldRefetchOnSizeChange,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        onRequestCompleted = onRequestCompleted,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ) { imageState -&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        when (imageState) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            is ImageLoadState.Success -&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // MaterialLoadingImage是0.6.2版本中存在的一个实现fadeIn效果的控件</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 原理是使用Compose动画中的Transition托管三个动画</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // alpha(透明度),brightness(亮度),saturation(饱和度), </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 同时修改传入Image内的colorFliter的这三个值，从而实现渐入效果</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                MaterialLoadingImage(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    result = imageState,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    contentDescription = contentDescription,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    fadeInEnabled = fadeIn,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    alignment = alignment,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    contentScale = contentScale,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    colorFilter = colorFilter</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            is ImageLoadState.Error -&gt; if (error != null) error(imageState)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ImageLoadState.Loading -&gt; if (loading != null) loading()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ImageLoadState.Empty -&gt; Unit</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Composable</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fun PicassoImage(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    data: Any,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    modifier: Modifier = Modifier,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    picasso: Picasso = LocalPicasso.current,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    requestBuilder: (RequestCreator.(size: IntSize) -&gt; RequestCreator)? = null,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    shouldRefetchOnSizeChange: (currentResult: ImageLoadState, size: IntSize) -&gt; Boolean = DefaultRefetchOnSizeChangeLambda,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    onRequestCompleted: (ImageLoadState) -&gt; Unit = EmptyRequestCompleteLambda,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    content: @Composable BoxScope.(imageLoadState: ImageLoadState) -&gt; Unit</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ImageLoad(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        request = data.toRequestCreator(picasso),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        requestKey = data, // Picasso RequestCreator doesn&#x27;t support equality so we use the data</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        executeRequest = { r -&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            @OptIn(ExperimentalCoroutinesApi::class)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            suspendCancellableCoroutine { cont -&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 初始化了一个Target，这个Target用来获取图片加载结果</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                val target = object : com.squareup.picasso.Target {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    override fun onBitmapLoaded(bitmap: Bitmap, from: Picasso.LoadedFrom) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        val state = ImageLoadState.Success(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            painter = BitmapPainter(bitmap.asImageBitmap()),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            source = from.toDataSource()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        // 协程恢复</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        cont.resume(state) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            // Not much we can do here. Ignore this</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    override fun onBitmapFailed(exception: Exception, errorDrawable: Drawable?) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        val state = ImageLoadState.Error(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            throwable = exception,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            painter = errorDrawable?.toPainter(),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        // 协程恢复</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        cont.resume(state) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            // Not much we can do here. Ignore this</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    override fun onPrepareLoad(placeholder: Drawable?) = Unit</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                cont.invokeOnCancellation {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 取消图片加载</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    picasso.cancelRequest(target)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // Now kick off the image load into our target</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                r.into(target)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        transformRequestForSize = { r, size -&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            val sizedRequest = when {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 如果尺寸包含未指定尺寸的尺寸，我们不会在Coil请求中指定尺寸</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                size.width &lt; 0 || size.height &lt; 0 -&gt; r</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">               </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                size != IntSize.Zero -&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    r.resize(size.width, size.height)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        .centerInside()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        .onlyScaleDown()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // Otherwise we have a zero size, so no point executing a request</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 未获得size，因此暂时无法生成请求</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                else -&gt; null</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 根据参数来build请求</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (sizedRequest != null &amp;&amp; requestBuilder != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // If we have a transformed request and builder, let it run</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                requestBuilder(sizedRequest, size)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // Otherwise we just return the sizedRequest</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                sizedRequest</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        shouldRefetchOnSizeChange = shouldRefetchOnSizeChange,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        onRequestCompleted = onRequestCompleted,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        modifier = modifier,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        content = content</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>现在让我们来总结一下，在0.6.2版本，实现网络图片加载的集成库思路如下：</p><ol><li>图片加载：使用<code>Target</code>回调获取加载的结果（各个框架都有类似的抽象的<code>Target</code>而不是限制目标必须是<code>ImageView</code>）。结果返回的过程是阻塞式，协程将在<code>produceState</code>内执行到<code> updatedExecuteRequest(transformedRequest)</code>后挂起，直到这个lambda返回结果，State的值将会在结果返回后产生变化。当然，如果协程被取消，Picasso也会取消加载到<code>Target</code>那个图片请求。</li><li>图片大小约束：依赖于<code>BoxWithConstraints</code>获得的约束大小。</li><li>渐入动画实现：使用动画API <code>Transition </code>对<code>ColorFliter</code>的alpha,brightness,saturation进行动态修改，从而实现渐入动画。</li><li>loading占位图、error显示等：依赖于用户传入的<code>@Composable</code>内容.根据<code>produceState</code>生成的状态，<code>PicassoImage</code>内显示的<code>@Composable</code>内容会动态变化。</li></ol><h2 class="anchor anchorWithStickyNavbar_mojV" id="glidein-version-0130">Glide(in version 0.13.0)<a class="hash-link" href="#glidein-version-0130" title="Direct link to heading">​</a></h2><p>0.3.0版本诞生于2020年10月份，而当时间来到了2021年4月，Accompanist发布0.8.0版本，Coil 和 Glide 集成库进行了大规模的重构。上面提到的类似于<code>CoilImage()</code>和<code>GlideImage()</code>API都已经被弃用了。</p><p>以下对Glide集成库的分析基于版本0.13.0的代码。</p><p>如果在0.13.0版本想要加载远程图片，或许你会写出以下的代码：</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">Image(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    painter = rememberGlidePainter(request = &quot;http://...&quot;),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    contentDescription = null</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>新的API不再需要专门的<code>Image</code>组件，而是使用<code>Painter</code>这种概念来表现加载的结果。新的API对性能的提升似乎有所提升：Compose内容重组后，需要重绘的不再是不同的Loading组件或Success组件，现在核心组件一定是一个<code>Image</code>，随加载状态变化的只不过是Image内绘制的内容而已，重绘范围有所缩小。这很符合我们对<code>ImageView</code>的想象：在加载的时候显示一张placeholder占位图，成功显示最终结果，否则显示error图片，而placeholder和error都可以发起图片加载请求的时候设置。</p><p>Painter是一个什么样的概念？我们可以先看一下类注释是怎么介绍它的：</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">* 对可以画出来的东西的抽象。除了能够绘制到指定的有界区域外，Painter还提供了一些高级机制，消费者可以使用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">* 这些机制来配置内容的绘制方式。其中包括alpha、ColorFilter和RTL</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">* 实现应该提供一个有意义的equals方法来比较不同Painter子类的值，而不仅仅依赖于引用相等</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">abstract class Painter {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    protected abstract fun DrawScope.onDraw()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>描述看起来有点像<code>Drawable</code>，但实际上<code>Drawable</code>比<code>Painter</code>更加复杂一些，除了上述的alpha、ColorFilter、LayoutDirection之外，<code>Drawable</code>还具有动画Callback、Level、Hotspot等属性。<code>DrawScope.onDraw()</code>方法类似于<code>Drawable</code>的<code>draw(Canvas canvas)</code>。</p><p>继续观察<code>rememberGlidePainter</code>的具体实现：</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">@Composable</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fun rememberGlidePainter(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    request: Any?,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    requestManager: RequestManager = GlidePainterDefaults.defaultRequestManager(),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    shouldRefetchOnSizeChange: ShouldRefetchOnSizeChange = ShouldRefetchOnSizeChange { _, _ -&gt; false },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 注意这里的requestBuilder，加载的结果类型已经被固定为drawable</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    requestBuilder: (RequestBuilder&lt;Drawable&gt;.(size: IntSize) -&gt; RequestBuilder&lt;Drawable&gt;)? = null,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 新的API也能开启fadeIn效果</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fadeIn: Boolean = false,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fadeInDurationMs: Int = LoadPainterDefaults.FadeInTransitionDuration,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 是不是很疑惑为什么这里有个占位图id的参数？Glide本身就支持占位图设置，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 在Build Request的时候设置不就行了吗？其实这个参数是给Compose预览模式用的</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @DrawableRes previewPlaceholder: Int = 0,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">): LoadPainter&lt;Any&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // GlideLoader是加载逻辑实现类，稍后展示</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    val glideLoader = remember {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        GlideLoader(requestManager, requestBuilder)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }.apply {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 这里的逻辑并不是多余的，要知道如果key没有变化，remember函数会直接返回上次计算的结果，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 这里想表达的是，对上次的结果调用apply，更新requestManager和requestBuilder</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.requestManager = requestManager</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.requestBuilder = requestBuilder</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // rememberLoadPainter位于之前所说的imageloading-core的核心库</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 在0.13.0版本Coil和Glide都用到这个库来获取LoadPainter</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return rememberLoadPainter(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        loader = glideLoader,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        request = checkData(request),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        shouldRefetchOnSizeChange = shouldRefetchOnSizeChange,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fadeIn = fadeIn,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fadeInDurationMs = fadeInDurationMs,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        previewPlaceholder = previewPlaceholder</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// checkData检查了request的类型</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private fun checkData(data: Any?): Any? {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    when (data) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        is Drawable -&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            throw IllegalArgumentException(....)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        is ImageBitmap -&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            throw IllegalArgumentException(....)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        is ImageVector -&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            throw IllegalArgumentException(....)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        is Painter -&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            throw IllegalArgumentException(....)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return data</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>imageloading-core这次如何抽象图片加载行为？我们先观察一下<code>rememberLoadPainter</code>的参数列表：</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">@Composable</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fun &lt;R&gt; rememberLoadPainter(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    loader: Loader&lt;R&gt;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    request: R?,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    shouldRefetchOnSizeChange: ShouldRefetchOnSizeChange,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fadeIn: Boolean = false,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fadeInDurationMs: Int = LoadPainterDefaults.FadeInTransitionDuration,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @DrawableRes previewPlaceholder: Int = 0,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">): LoadPainter&lt;R&gt; {...}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Stable</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fun interface Loader&lt;R&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fun load(request: R, size: IntSize): Flow&lt;ImageLoadState&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>与0.6.2版本不同，加载逻辑实现类需要返回一个状态流<code>Flow&lt;ImageLoadState&gt;</code>，而不再是单一的<code>ImageLoadState</code>，虽然请求类型仍然是泛型的，但是已经不需要表达类似于<code>RequestBuilder</code>这样的泛型类型，如何构建、发起请求由<code>Loader</code>自己决定。</p><p><code>ImageLoadState</code>的实现如下</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">sealed class ImageLoadState {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    object Empty : ImageLoadState()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    data class Loading(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        val placeholder: Painter?,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        val request: Any,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ) : ImageLoadState()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    data class Success(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        val result: Painter,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        val source: DataSource,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        val request: Any,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ) : ImageLoadState()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    data class Error(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        val request: Any,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        val result: Painter? = null,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        val throwable: Throwable? = null</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ) : ImageLoadState()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>不难发现所有的图片加载结果都要求封装成<code>Painter</code>进行返回，但尴尬的是，<code>Drawable</code>与<code>Painter</code>并不是天生互通的类型（Compose 1.0.5只有三种<code>Painter</code>，<code>BitmapPainter</code>、<code>VectorPainter</code>、<code>ColorPainter</code>），好在Accompanist提供了一个<code>DrawablePainter</code>。不过话又说回来，为什么非得要求生产者Loader返回<code>Painter</code>不可呢？那是因为加载请求是多类型的，消费者LoadPainter其实无法确定生产者返回的结果的类型，自然也不确定如何绘制它，因此LoadPainter采用了类似于装饰者模式的设计，图片结果绘制交由State内的Painter完成。</p><p><code>GlideLoader</code>的实现如下：</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">internal class GlideLoader(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    requestManager: RequestManager,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    requestBuilder: (RequestBuilder&lt;Drawable&gt;.(size: IntSize) -&gt; RequestBuilder&lt;Drawable&gt;)?,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">) : Loader&lt;Any&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    var requestManager by mutableStateOf(requestManager)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    var requestBuilder by mutableStateOf(requestBuilder)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 不要删除callbackFlow上的显式类型&lt;ImageLoadState&gt;。IR编译器不喜欢隐式类型。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Suppress(&quot;RemoveExplicitTypeArguments&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @OptIn(ExperimentalCoroutinesApi::class)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    override fun load(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        request: Any,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        size: IntSize</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ): Flow&lt;ImageLoadState&gt; = callbackFlow&lt;ImageLoadState&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        var failException: Throwable? = null</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 这里同时使用Target与Listener两种机制来监听加载状态，并向flow发送对应状态</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Target并不会去处理Success的状态，Listener已经抢先处理并拦截了Target的Success调用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        val target = object : EmptyCustomTarget(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (size.width &gt; 0) size.width else Target.SIZE_ORIGINAL,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (size.height &gt; 0) size.height else Target.SIZE_ORIGINAL</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            override fun onLoadStarted(placeholder: Drawable?) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                trySendBlocking(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    ImageLoadState.Loading(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        placeholder = placeholder?.let(::DrawablePainter),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        request = request</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            override fun onLoadFailed(errorDrawable: Drawable?) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                trySendBlocking(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    ImageLoadState.Error(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        result = errorDrawable?.let(::DrawablePainter),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        request = request,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        throwable = failException</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            ?: IllegalArgumentException(&quot;Error while loading $request&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // Close the channel[Flow]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                channel.close()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            override fun onLoadCleared(resource: Drawable?) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // Glide想要释放资源，所以我们需要清除结果，否则我们可能会绘制已经被回收的视图</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                trySendBlocking(ImageLoadState.Empty)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // Close the channel[Flow]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                channel.close()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        val listener = object : RequestListener&lt;Drawable&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            override fun onResourceReady(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                drawable: Drawable,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                model: Any,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                target: Target&lt;Drawable&gt;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                dataSource: com.bumptech.glide.load.DataSource,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                isFirstResource: Boolean</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ): Boolean {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 这里发送的Painter类型</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                trySendBlocking(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    ImageLoadState.Success(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        result = DrawablePainter(drawable),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        source = dataSource.toDataSource(),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        request = request</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // Close the channel[Flow]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                channel.close()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // Return true so that the target doesn&#x27;t receive the drawable</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 这里返回true，Target就收不到结果了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                return true</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            override fun onLoadFailed(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                e: GlideException?,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                model: Any,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                target: Target&lt;Drawable&gt;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                isFirstResource: Boolean</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ): Boolean {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // Glide只为Listener派发错误的Exception，因此这里需要缓存一下</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                failException = e</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 返回false，允许Target被回调onLoadFailed</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                return false</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Start the image request into the target</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        requestManager.load(request)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            .apply { requestBuilder?.invoke(this, size) }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            .addListener(listener)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            .into(target)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Await the channel being closed and request finishing...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        awaitClose {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 这里没有调用Glide.clear()，因为clear之后Painter进行绘制的位图可能会被回收，这会报错</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // See https://github.com/google/accompanist/issues/419</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>总体来说状态转换逻辑和以前类似，只不过使用<code>callbackFlow</code>生成数据流后，状态发送显得更加优雅了。</p><p>接下来关注<code>rememberLoadPainter</code>的具体实现：</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">一个通用的 image loading painter，它为要实现的图像加载库提供Loader接口。应用程序通常不应该使用此功能，而更推荐使用在此基础上构建的扩展库，例如Coil和Glide库。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Composable</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fun &lt;R&gt; rememberLoadPainter(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    loader: Loader&lt;R&gt;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    request: R?,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    shouldRefetchOnSizeChange: ShouldRefetchOnSizeChange,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fadeIn: Boolean = false,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fadeInDurationMs: Int = LoadPainterDefaults.FadeInTransitionDuration,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @DrawableRes previewPlaceholder: Int = 0,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">): LoadPainter&lt;R&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    val coroutineScope = rememberCoroutineScope()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // Our LoadPainter. This invokes the loader as appropriate to display the result.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    val painter = remember(loader, coroutineScope) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        LoadPainter(loader, coroutineScope)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    painter.request = request</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    painter.shouldRefetchOnSizeChange = shouldRefetchOnSizeChange</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 缓存父布局的大小，在计算图片请求的大小时会参考此值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    painter.rootViewSize = LocalView.current.let { IntSize(it.width, it.height) }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // fadeIn动画的ColorFilter</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 实现原理和0.6.2版本类似，也是修改了ColorFliter的alpha(透明度),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // brightness(亮度),saturation(饱和度)，不过这次的ColorFliter由LoadPainter直接进行处理</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    animateFadeInColorFilter(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        painter = painter,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        enabled = { result -&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 从 disk/network 才去展示fadeIn动画</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 这使我们可以近似地只在“首次加载”时运行动画</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            fadeIn &amp;&amp; result is ImageLoadState.Success &amp;&amp; result.source != DataSource.MEMORY</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        durationMs = fadeInDurationMs,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // Our result painter, created from the ImageState with some composition lifecycle</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // callbacks</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 我们的result painter，通过一些composition生命周期的回调从ImageState创建</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    updatePainter(painter, previewPlaceholder)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return painter</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p><code>LoaderPainter</code>的实现如下。这里要特别注意<code>RememberObserver</code>这个接口，<code>RememberObserver</code>是一个能够实现对remember行为的观察的接口，如果composition记住或者遗忘的是一个<code>RememberObserver</code>对象，<code>RememberObserver</code>能够收到这个事件，这些事件对<code>LoaderPainter</code>很有用。因为LoaderPainter毕竟并不是一个Compose组件，但是它必须了解它所在的父组件在什么时候离开了屏幕被销毁了（例如高速滑动列表时），这样它能够及时取消对状态流<code>Flow&lt;ImageLoadState&gt;</code>的收集，这是避免发生图片闪烁、错位等问题的关键。</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">class LoadPainter&lt;R&gt; internal constructor(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private val loader: Loader&lt;R&gt;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private val coroutineScope: CoroutineScope,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">) : Painter(), RememberObserver {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private val paint by lazy(LazyThreadSafetyMode.NONE) { Paint() }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    internal var painter by mutableStateOf&lt;Painter&gt;(EmptyPainter)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 这个ColorFilter和渐入动画有关</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    internal var transitionColorFilter by mutableStateOf&lt;ColorFilter?&gt;(null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // CoroutineScope for the current request</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private var requestCoroutineScope: CoroutineScope? = null</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * The current request object.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    var request by mutableStateOf&lt;R?&gt;(null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * The root view size.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    internal var rootViewSize by mutableStateOf(IntSize(0, 0))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * Lambda which will be invoked when the size changes, allowing</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * optional re-fetching of the image.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    var shouldRefetchOnSizeChange by mutableStateOf(ShouldRefetchOnSizeChange { _, _ -&gt; false })</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * The current [ImageLoadState].</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 被观察的ImageLoadState</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    var loadState: ImageLoadState by mutableStateOf(ImageLoadState.Empty)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        private set</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private var alpha: Float by mutableStateOf(1f)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private var colorFilter: ColorFilter? by mutableStateOf(null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 执行图像加载请求时要使用的大小</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private var requestSize by mutableStateOf&lt;IntSize?&gt;(null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // Painter内的属性，指定边界大小</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    override val intrinsicSize: Size</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        get() = painter.intrinsicSize</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    override fun applyAlpha(alpha: Float): Boolean {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.alpha = alpha</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return true</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    override fun applyColorFilter(colorFilter: ColorFilter?): Boolean {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.colorFilter = colorFilter</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return true</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    override fun DrawScope.onDraw() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 根据Canvas的大小确定requestSize，是不是注意到requestSize的确定其实是存在延时的？</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        updateRequestSize(canvasSize = size)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 下面是一些绘制逻辑</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        val transitionColorFilter = transitionColorFilter</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (colorFilter != null &amp;&amp; transitionColorFilter != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // If we have a transition color filter, </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // and a specified color filter we need to</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // draw the content in a layer for both to apply.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // See https://github.com/google/accompanist/issues/262</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">           drawIntoCanvas { canvas -&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                paint.colorFilter = transitionColorFilter</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                canvas.saveLayer(bounds = size.toRect(), paint = paint)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                with(painter) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    draw(size, alpha, colorFilter)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                canvas.restore()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // Otherwise we just draw the content directly, using the filter</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            with(painter) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                draw(size, alpha, colorFilter ?: transitionColorFilter)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // RememberObserver的方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // remember运行了计算的lambda但是composition没记住这个对象时回调</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    override fun onAbandoned() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // We&#x27;ve been abandoned from composition, so cancel our request scope</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        requestCoroutineScope?.cancel()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        requestCoroutineScope = null</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // RememberObserver的方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // composition忘记了这个对象时回调</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    override fun onForgotten() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // We&#x27;ve been forgotten from composition, so cancel our request scope</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // onAbandoned和onForgotten时都会cancel运行中的协程</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        requestCoroutineScope?.cancel()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        requestCoroutineScope = null</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // RememberObserver的方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 当composition成功记住此对象时调用。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    override fun onRemembered() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Cancel any on-going scope (this shouldn&#x27;t really happen anyway)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 先取消以前正running的协程</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        requestCoroutineScope?.cancel()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 为当前请求创建新的scope，这允许我们取消作用域，而不影响父作用域的作业。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        val scope = coroutineScope.coroutineContext.let { context -&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            CoroutineScope(context + Job(context[Job]))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }.also { requestCoroutineScope = it }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 我们已经被记住了，所以可以启动一个协程来观察当前的请求对象和请求大小。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 每当这些值中的任何一个发生变化时，collectLatest块将运行并执行图像加载（任何正在进行的请求都将被取消）。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        scope.launch {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // combine方法如其名，能把两个流合并成一个流</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 不过为什么这里要使用snapshotFlow把State转化成流呢？</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 因为使用流来监听State变化的最大好处就是collectLatest能够</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 取消掉上一次的execute调用并启动新一轮的加载</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            combine(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                snapshotFlow { request },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                snapshotFlow { requestSize },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                transform = { request, size -&gt; request to size }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ).collectLatest { (request, size) -&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                execute(request, size)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 自动保险。如果没有从onDraw()获得合适的大小，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 我们会将请求大小更新为-1，-1，这将加载原始大小的图像。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        scope.launch {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (requestSize == null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 32ms should be enough time for measure/layout/draw to happen.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 微妙的32毫秒</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                delay(32) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (requestSize == null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                   // If we still don&#x27;t have a request size, resolve the size without</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                   // the canvas size</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 没获取到Canvas大小，使用原始尺寸</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    updateRequestSize(canvasSize = Size.Zero)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 执行图片加载请求并根据结果更新loadState的方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     下面描述的是一些状态转换逻辑，比如如果请求为null，状态就转变为Empty</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private suspend fun execute(request: R?, size: IntSize?) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (request == null || size == null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // If we don&#x27;t have a request, set our state to Empty and return</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            loadState = ImageLoadState.Empty</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        loader.load(request, size)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            .catch { throwable -&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                when (throwable) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    is Error -&gt; throw throwable</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    is IllegalStateException -&gt; throw throwable</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    is IllegalArgumentException -&gt; throw throwable</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    else -&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        emit(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            ImageLoadState.Error(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                result = null,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                throwable = throwable,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                request = request</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            .collect { loadState = it }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 上面collect收集了加载的状态，注意，代表图片结果的Painter没被设置到LoadPainter的字段内</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private fun updateRequestSize(canvasSize: Size) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        requestSize = IntSize(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            width = when {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // If we have a canvas width, use it...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                canvasSize.width &gt;= 0.5f -&gt; canvasSize.width.roundToInt()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 还记得这个rootViewSize吗？它在rememberLoadPainter函数内被设置</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                rootViewSize.width &gt; 0 -&gt; rootViewSize.width</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                else -&gt; -1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            height = when {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // If we have a canvas height, use it...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                canvasSize.height &gt;= 0.5f -&gt; canvasSize.height.roundToInt()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // Otherwise we fall-back to the root view size as an upper bound</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                rootViewSize.height &gt; 0 -&gt; rootViewSize.height</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                else -&gt; -1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>虽然说<code>LoadPainter</code>确实是实现了<code>RememberObserver</code>，但是，这个回调是怎么被注册的呢？答案藏在习以为常的<code>remember</code>函数中，传入<code>remember</code>的key，或者是calculation得出的值，它们如果是个<code>RememberObserver</code>，则会被插入到<code>RememberManager</code>的队列中，每当“记忆”和“遗忘”事件发生时都会得到通知。</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">@Composable</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">inline fun &lt;T&gt; remember(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    key1: Any?,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    calculation: @DisallowComposableCalls () -&gt; T</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">): T {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return currentComposer.cache(currentComposer.changed(key1), calculation)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 注意检查key是否有变化的changed函数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@ComposeCompilerApi</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">override fun changed(value: Any?): Boolean {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return if (nextSlot() != value) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        updateValue(value)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        true</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        false</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@PublishedApi</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@OptIn(InternalComposeApi::class)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">internal fun updateValue(value: Any?) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 两个if分支我们都可以看到 rememberManager.remembering()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // rememberManager.forgetting()这些调用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (inserting) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        writer.update(value)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (value is RememberObserver) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 注意，判断value是不是RememberObserver</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            record { _, _, rememberManager -&gt; rememberManager.remembering(value) }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        val groupSlotIndex = reader.groupSlotIndex - 1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        recordSlotTableOperation(forParent = true) { _, slots, rememberManager -&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (value is RememberObserver) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                abandonSet.add(value)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                rememberManager.remembering(value)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            when (val previous = slots.set(groupSlotIndex, value)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                is RememberObserver -&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    rememberManager.forgetting(previous)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                is RecomposeScopeImpl -&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    val composition = previous.composition</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    if (composition != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        previous.composition = null</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        composition.pendingInvalidScopes = true</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// RememberManager是个接口</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">internal interface RememberManager {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * The [RememberObserver] is being remembered by a slot in the slot table.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fun remembering(instance: RememberObserver)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * The [RememberObserver] is being forgotten by a slot in the slot table.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fun forgetting(instance: RememberObserver)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// RememberManager的实现类</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private class RememberEventDispatcher(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private val abandoning: MutableSet&lt;RememberObserver&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">) : RememberManager {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private val remembering = mutableListOf&lt;RememberObserver&gt;()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private val forgetting = mutableListOf&lt;RememberObserver&gt;()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private val sideEffects = mutableListOf&lt;() -&gt; Unit&gt;()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    override fun remembering(instance: RememberObserver) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        forgetting.lastIndexOf(instance).let { index -&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (index &gt;= 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                forgetting.removeAt(index)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                abandoning.remove(instance)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                remembering.add(instance)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    override fun forgetting(instance: RememberObserver) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        remembering.lastIndexOf(instance).let { index -&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (index &gt;= 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                remembering.removeAt(index)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                abandoning.remove(instance)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                forgetting.add(instance)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fun dispatchRememberObservers() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 派发forgetting和remembering事件的逻辑</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (forgetting.isNotEmpty()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for (i in forgetting.size - 1 downTo 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                val instance = forgetting[i]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (instance !in abandoning) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    instance.onForgotten()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (remembering.isNotEmpty()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            remembering.fastForEach { instance -&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                abandoning.remove(instance)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                instance.onRemembered()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // ....</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>我们已经明白<code>LoadPainter</code>到底是怎么管理Loader返回的流结果了，最后一个需要注意的地方在函数<code>updatePainter</code>里，这个调用位于<code>rememberLoadPainter</code>最后，函数实现会根据图片加载State的变化来为LoadPainter设置Painter。不过这不是兜了个圈子吗？似乎也可以在collect更新State的同时把Painter更新一下？</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">* 允许我们以状态观察当前结果。这个函数允许我们最小化重组范围，这样当loadState改变时，只有这个函数需要重新</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">* 启动。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Composable</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private fun &lt;R&gt; updatePainter(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    loadPainter: LoadPainter&lt;R&gt;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @DrawableRes previewPlaceholder: Int = 0,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    loadPainter.painter = if (LocalInspectionMode.current &amp;&amp; previewPlaceholder != 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 如果我们处于检查模式（预览），并且有一个预览占位符，只需使用图像绘制它并返回</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 还记得rememberGlidePainter的参数吗？这里就是传入的参数previewPlaceholder的用途</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 这个函数令LoadPainter完全忽略了State的变化，只展示静态图片</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        painterResource(previewPlaceholder)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // remember在这里看上去像是毫无必要的调用，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 但这允许任何Painter实例接收记忆事件（如果它实现了RememberObserver）。不要移除。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        remember(loadPainter.loadState) { loadPainter.loadState.painter } ?: EmptyPainter</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>现在来总结一下0.13.0版本的Glide远程图片扩展的实现思路：</p><ol><li><p>图片加载：依然是用Target回调获取加载的结果。但是加载状态的返回现在使用流（Flow）来封装，不管是发起加载，异常处理，加载取消都更加优雅直观了。Loader是彻彻底底的生产者，<code>LoadPainter</code>则是消费者。</p><p><code>LoadPainter</code>并不具有@Composable上下文，作为替代，它实现了<code>RememberObserver</code>来监听控件是否已经离屏销毁。</p></li><li><p>图片大小约束：依赖于LoadPainter获取的Canvas的大小。</p></li><li><p>渐入动画实现：跟0.6.2版本的思路相似，不过消费ColorFilter的类变成了LoadPainter。</p></li><li><p>loading占位图、error图等：这些功能直接依赖于具体的图片加载框架的实现，有则有，无则无。0.13.0版本稍微舍去了一些灵活性，不能够像PicassoImage一样直接传入error、loading的Compose内容（控件），不过仍然留有监听图片加载状态的方式，注意，LoadPainter的<code>loadState</code>字段是公开的：</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * The current [ImageLoadState].</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">var loadState: ImageLoadState by mutableStateOf(ImageLoadState.Empty)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private set</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div></li></ol><h2 class="anchor anchorWithStickyNavbar_mojV" id="coil">Coil<a class="hash-link" href="#coil" title="Direct link to heading">​</a></h2><p>Accompanist内的Coil集成库最终集成到了Coil内部，成为其扩展，Glide的集成支持则在2021年8月的0.16.0版本被删除。</p><p>现在我们简要分析Coil的图片加载逻辑（版本2.0.0-alpha06）。Coil扩展库提供了两种方式来加载网络图片，两种方式正巧就是上面提到的在0.6.2版本与在0.13.0版本的两种实现形式：</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">// 实现形式1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Composable</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fun AsyncImage(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    model: Any?,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    contentDescription: String?,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    imageLoader: ImageLoader,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    modifier: Modifier = Modifier,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    loading: @Composable (AsyncImageScope.(State.Loading) -&gt; Unit)? = null,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    success: @Composable (AsyncImageScope.(State.Success) -&gt; Unit)? = null,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    error: @Composable (AsyncImageScope.(State.Error) -&gt; Unit)? = null,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    alignment: Alignment = Alignment.Center,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    contentScale: ContentScale = ContentScale.Fit,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    alpha: Float = DefaultAlpha,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    colorFilter: ColorFilter? = null,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    filterQuality: FilterQuality = DefaultFilterQuality,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">) {...}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 实现形式2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Composable</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fun rememberAsyncImagePainter(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    model: Any?,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    imageLoader: ImageLoader,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    filterQuality: FilterQuality = DefaultFilterQuality,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">): AsyncImagePainter {...}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>我们重点分析第二种形式，即rememberAsyncImagePainter函数，其实该函数的实现逻辑与Glide扩展库比较类似，只在某些细节有所区别：</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">// 这里不再详细分析源码，挑重要的讲</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Composable</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fun rememberAsyncImagePainter(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    model: Any?,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    imageLoader: ImageLoader,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    filterQuality: FilterQuality = DefaultFilterQuality,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">): AsyncImagePainter {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    val request = requestOf(model)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    requireSupportedData(request.data)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 注意这里，这里要求request的target为null</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    require(request.target == null) { &quot;request.target must be null.&quot; }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // Dispatchers.Main.immediate是一个有趣的协程调度器，具体效果见类注释</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    val scope = rememberCoroutineScope { Dispatchers.Main.immediate }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // AsyncImagePainter</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    val painter = remember(scope) { AsyncImagePainter(scope, request, imageLoader) }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    painter.request = request</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    painter.imageLoader = imageLoader</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    painter.filterQuality = filterQuality</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 是否处于预览模式</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    painter.isPreview = LocalInspectionMode.current</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 这里手动调用了一次onRemembered，onRemembered里有向ImageLoader提交request的逻辑</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    painter.onRemembered() // Invoke this manually so `painter.state` is up to date immediately.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 这里的updatePainter更加复杂，里面有处理fadeIn动画的逻辑</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    updatePainter(painter, request, imageLoader)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return painter</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>Dispatchers.Main.immediate比单纯的Dispatchers.Main更加智能，它会减少不必要的调度，当它已经在正确的上下文中，它会立刻执行相应逻辑而无需额外的重新调度。效果类似于下面这样：</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">suspend fun updateUiElement(val text: String) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   * 假设updateUiElement既会被Main线程调用也会被其他线程调用。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   * 那么，当updateUiElement是在Main线程被调用的，更新uiElement.text 这段代码会直接运行，而换成Dispatchers.Main的话，它会再进行一次到Main的调度（明显这是赘余的调度）。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  withContext(Dispatchers.Main.immediate) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    uiElement.text = text</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // Do context-independent logic such as logging</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>接下来我们关注AsyncImagePainter的具体实现：</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 异步执行ImageRequest并呈现结果的Painter。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class AsyncImagePainter internal constructor(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private val parentScope: CoroutineScope,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    request: ImageRequest,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    imageLoader: ImageLoader</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">) : Painter(), RememberObserver {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private var rememberScope: CoroutineScope? = null</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 图片请求的协程的Job</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private var requestJob: Job? = null</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private var drawSize = MutableStateFlow(Size.Zero)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private var alpha: Float by mutableStateOf(1f)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private var colorFilter: ColorFilter? by mutableStateOf(null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    internal var painter: Painter? by mutableStateOf(null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    internal var filterQuality = DefaultFilterQuality</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    internal var isPreview = false</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /** The current [AsyncImagePainter.State]. */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    var state: State by mutableStateOf(State.Empty)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        private set</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    var request: ImageRequest by mutableStateOf(request)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        internal set</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    var imageLoader: ImageLoader by mutableStateOf(imageLoader)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        internal set</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    override val intrinsicSize: Size</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        get() = painter?.intrinsicSize ?: Size.Unspecified</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    override fun DrawScope.onDraw() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 绘制逻辑非常清爽</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        drawSize.value = size</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Draw the current painter.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        painter?.apply { draw(size, alpha, colorFilter) }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    override fun onRemembered() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 如果我们处于检查模式（预览），请跳过执行图像请求，并将状态设置为加载。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 对于预览模式的支持</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (isPreview) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            val request = request.newBuilder().defaults(imageLoader.defaults).build()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            state = State.Loading(request.placeholder?.toPainter())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 与Glide扩展类似，创建了一个子作用域</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (rememberScope != null) return</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        val scope = parentScope + SupervisorJob(parentScope.coroutineContext.job)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        rememberScope = scope</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 观察当前请求+请求大小，并根据需要启动新请求。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Coil天然支持Kotlin协程，无需为生产者额外编写代码</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        scope.launch {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            snapshotFlow { request }.collect { request -&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                requestJob?.cancel()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                requestJob = launch {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // execute是挂起函数，返回ImageResult</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    state = imageLoader.execute(updateRequest(request)).toState()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    override fun onForgotten() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        rememberScope?.cancel()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        rememberScope = null</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        requestJob?.cancel()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        requestJob = null</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    override fun onAbandoned() = onForgotten()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /** Update the [request] to work with [AsyncImagePainter]. */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private fun updateRequest(request: ImageRequest): ImageRequest {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return request.newBuilder()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            .target(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                onStart = { placeholder -&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                     // 这里获取到placeholder的Painter并更新State为Loading</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    state = State.Loading(placeholder?.toPainter())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            .apply {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (request.defined.sizeResolver == null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // Coil内关于设置图片大小的代码</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // size接受一个SizeResolver，一个含suspend函数的接口</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 获取尺寸的函数是挂起函数，非常合理，因为很多时候需要等待控件测量完毕才知道大小</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    size(DrawSizeResolver())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (request.defined.precision != Precision.EXACT) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    precision(Precision.INEXACT)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            .build()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private fun ImageResult.toState() = when (this) {....}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private fun Drawable.toPainter() = when (this) {...}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /** Suspends until the draw size for this [AsyncImagePainter] is unspecified or positive. */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private inner class DrawSizeResolver : SizeResolver {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        override suspend fun size() = drawSize</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            .mapNotNull { size -&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                when {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // mapNotNull会将drawSize转化为Flow，同时过滤null值，然后挂起函数first()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 将会返回Flow中传送的第一个值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    size.isUnspecified -&gt; CoilSize.ORIGINAL</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    size.isPositive -&gt; CoilSize(size.width.roundToInt(), size.height.roundToInt())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    else -&gt; null</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            .first()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * The current state of the [AsyncImagePainter].</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 状态定义</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    sealed class State {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        abstract val painter: Painter?</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        object Empty : State() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            override val painter: Painter? get() = null</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        data class Loading(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            override val painter: Painter?,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ) : State()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        data class Success(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            override val painter: Painter,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            val result: SuccessResult,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ) : State()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        data class Error(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            override val painter: Painter?,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            val result: ErrorResult,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ) : State()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>与Glide扩展库的思路类似，updatePainter函数会监听AsyncImagePainter的加载状态变化，同时更新AsyncImagePainter内的Painter字段。</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">@Composable</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private fun updatePainter(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    imagePainter: AsyncImagePainter,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    request: ImageRequest,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    imageLoader: ImageLoader</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // This may look like a useless remember, but this allows any painter instances</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // to receive remember events (if it implements RememberObserver). Do not remove.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 与Glide扩展库一样，允许结果Painter实例接收remember事件（如果它实现了RememberObserver）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    val state = imagePainter.state</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    val painter = remember(state) { state.painter }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 如果没有CrossfadeTransition（实现渐入变换）的话，直接设置imagePainter.painter并返回</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    val transition = request.defined.transitionFactory ?: imageLoader.defaults.transitionFactory</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (transition !is CrossfadeTransition.Factory) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        imagePainter.painter = painter</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // ValueHolder是一个包含static field的数据类，目的是储存state.painter的值，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 避免在state.painter值更新后函数rememberCrossfadePainter重组，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 与rememberUpdatedState有异曲同工之妙，估计是因为rememberUpdatedState没有</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 传入key的API（这里要监听request变化），所以这里提供了简易的避免重组的实现</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    val loading = remember(request) { ValueHolder&lt;Painter?&gt;(null) }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (state is State.Loading) loading.value = state.painter</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 必须位于Success状态且图片是从网络或磁盘加载的，才允许启动Crossfade，否则返回即可</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (state !is State.Success || state.result.dataSource == DataSource.MEMORY_CACHE) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        imagePainter.painter = painter</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // Set the crossfade painter.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 千呼万唤始出来的CrossfadePainter</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    imagePainter.painter = rememberCrossfadePainter(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        key = state,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        start = loading.value,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        end = painter,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        scale = request.scale,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        durationMillis = transition.durationMillis,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fadeStart = !state.result.isPlaceholderCached,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        preferExactIntrinsicSize = transition.preferExactIntrinsicSize</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/** A simple mutable value holder that avoids recomposition. */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 使用静态字段（static）避免重组</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private class ValueHolder&lt;T&gt;(@JvmField var value: T)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>CrossfadePainter的实现如下：</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">@Stable</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private class CrossfadePainter(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private var start: Painter?,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private val end: Painter?,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private val scale: Scale,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private val durationMillis: Int,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private val fadeStart: Boolean,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private val preferExactIntrinsicSize: Boolean,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">) : Painter() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private var invalidateTick by mutableStateOf(0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private var startTimeMillis = -1L</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private var isDone = false</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private var maxAlpha: Float by mutableStateOf(1f)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private var colorFilter: ColorFilter? by mutableStateOf(null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    override val intrinsicSize get() = computeIntrinsicSize()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    override fun DrawScope.onDraw() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 如果Alpha变化完毕，直接使用end绘制</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (isDone) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            drawPainter(end, maxAlpha)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Initialize startTimeMillis the first time we&#x27;re drawn.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        val uptimeMillis = SystemClock.uptimeMillis()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (startTimeMillis == -1L) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            startTimeMillis = uptimeMillis</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Alpha的百分比 = (当前时间 - 开始时间) / 持续时间</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        val percent = (uptimeMillis - startTimeMillis) / durationMillis.toFloat()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        val endAlpha = percent.coerceIn(0f, 1f) * maxAlpha</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        val startAlpha = if (fadeStart) maxAlpha - endAlpha else maxAlpha</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        isDone = percent &gt;= 1.0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Loading占位图渐出，Success图片结果渐入</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        drawPainter(start, startAlpha)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        drawPainter(end, endAlpha)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (isDone) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            start = null</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // Increment this value to force the painter to be redrawn.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            invalidateTick++</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>现在来总结一下Coil远程图片扩展的实现思路：</p><ol><li><p>图片加载：Coil对协程提供直接的支持，<code>size</code>函数、<code>execute</code>加载函数本身就是挂起函数，因此无需额外的转换逻辑。而<code>AsyncImagePainter</code>则使用Job来控制图片加载协程。</p><p><code>AsyncImagePainter</code>并不具有@Composable上下文，作为替代，它实现了<code>RememberObserver</code>来监听控件是否已经离屏销毁。</p></li><li><p>图片大小约束：依赖于<code>DrawContext</code>的Size。</p></li><li><p>渐入动画实现：依赖于<code>DrawScope.onDraw()</code>内的重绘行为，通过对透明度Alpha的百分比计算来实现，令Loading状态的占位图渐出，Success状态的最终结果渐入。</p></li><li><p>loading占位图、error图等：由Coil提供具体的实现。</p></li></ol><p>根据上述分析我们可以发现，相比于Glide或是Picasso，基于Kotlin协程实现的图片加载库Coil，的确能够很轻松与Jetpack Compose配合工作。</p><p>至此对扩展库的分析已经完毕。横向对比来说，无论是对Picasso还是Glide进行扩展，我们都得额外做一些处理，才能够令本身不支持协程的它们在Compose下正常工作。要注意的是，单纯使用自定义的Target把结果返回到某个State，这种简单的做法在列表中可能会遇到严重的性能问题，因为Glide也好，Picasso也好，它们内部实现中取消图片加载以避免图片错位、闪烁的重要参照物就是ImageView，随着列表滑动不断创建的自定义的Target无法被它们识别并进行相应处理。相比之下基于协程的Coil的加载能够变得简单得多，我们只需要利用Job本身就可以控制加载的协程。</p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/compose-museum/jetpack-compose-book/tree/master/docs/principle/composeRemoteImage.mdx" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_dcUD" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_foO9"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/docs/principle/composeAnnotation"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">Compose 注解到底做了什么？</div></a></div><div class="pagination-nav__item pagination-nav__item--next"></div></nav></div></div><div class="col col--3"><div class="tableOfContents_cNA8 thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#前言" class="table-of-contents__link toc-highlight">前言</a></li><li><a href="#picassoin-version-062" class="table-of-contents__link toc-highlight">Picasso(in version 0.6.2)</a></li><li><a href="#glidein-version-0130" class="table-of-contents__link toc-highlight">Glide(in version 0.13.0)</a></li><li><a href="#coil" class="table-of-contents__link toc-highlight">Coil</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">社区</div><ul class="footer__items"><li class="footer__item"><a href="https://github.com/compose-museum" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Github<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2022 Jetpack Compose 博物馆, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.ae8d57c9.js"></script>
<script src="/assets/js/main.50fd7d2b.js"></script>
</body>
</html>