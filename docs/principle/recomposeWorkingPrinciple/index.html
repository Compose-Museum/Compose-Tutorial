<!doctype html>
<html class="docs-version-current" lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.15">
<title data-react-helmet="true">重组的工作流程 | 你好 Compose</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:url" content="https://jetpackcompose.cn/docs/principle/recomposeWorkingPrinciple"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="重组的工作流程 | 你好 Compose"><meta data-react-helmet="true" name="description" content="我们都知道 Jetpack Compose 是一套声明式 UI 系统，当 UI 组件所依赖的状态发生改变时会自动发生重绘刷新，这个过程被官方称作重组，前面已经总结过 Compose 的重组范围，以及 重组过程使用的Snapshot。本文将带领大家来看看 Compose 源码中从状态更新到 recompose 过程在源码中是如何进行的，并且讲解快照系统在 recompose 过程中如何被使用到的。"><meta data-react-helmet="true" property="og:description" content="我们都知道 Jetpack Compose 是一套声明式 UI 系统，当 UI 组件所依赖的状态发生改变时会自动发生重绘刷新，这个过程被官方称作重组，前面已经总结过 Compose 的重组范围，以及 重组过程使用的Snapshot。本文将带领大家来看看 Compose 源码中从状态更新到 recompose 过程在源码中是如何进行的，并且讲解快照系统在 recompose 过程中如何被使用到的。"><link data-react-helmet="true" rel="icon" href="/img/logo.svg"><link data-react-helmet="true" rel="canonical" href="https://jetpackcompose.cn/docs/principle/recomposeWorkingPrinciple"><link data-react-helmet="true" rel="alternate" href="https://jetpackcompose.cn/docs/principle/recomposeWorkingPrinciple" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://jetpackcompose.cn/docs/principle/recomposeWorkingPrinciple" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.cba56bc1.css">
<link rel="preload" href="/assets/js/runtime~main.8d46e49c.js" as="script">
<link rel="preload" href="/assets/js/main.4fa214f8.js" as="script">
</head>
<body data-theme="light">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region"><a href="#" class="skipToContent_ZgBM">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_W2Cr themedImage--light_TfLj"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_W2Cr themedImage--dark_oUvU"></div><b class="navbar__title">Jetpack Compose 博物馆</b></a><a class="navbar__item navbar__link navbar__link--active" href="/docs/">文档</a><a class="navbar__item navbar__link" href="/docs/open-source-project/compose-douban">开源项目</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/milklabdev/jetpack-compose-book" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><div class="toggle_Pssr toggle_TdHA toggleDisabled_jDku"><div class="toggleTrack_SSoT" role="button" tabindex="-1"><div class="toggleTrackCheck_XobZ"><span class="toggleIcon_eZtF">🌜</span></div><div class="toggleTrackX_YkSC"><span class="toggleIcon_eZtF">🌞</span></div><div class="toggleTrackThumb_uRm4"></div></div><input type="checkbox" class="toggleScreenReader_JnkT" aria-label="Switch between dark and light mode"></div><div class="dsla-search-wrapper"><div class="dsla-search-field" data-tags="default,docs-default-current"></div></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docs-wrapper docs-doc-page"><div class="docPage_P2Lg"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_RiI4" type="button"></button><aside class="theme-doc-sidebar-container docSidebarContainer_rKC_"><div class="sidebar_CW9Y"><nav class="menu thin-scrollbar menu_SkdO"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/">写在开头</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link hasHref_VCh3" href="/docs/category/入门">入门</a><button aria-label="Toggle the collapsible sidebar category &#x27;入门&#x27;" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/installation">安装或更新 Android Studio</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/tutorial">初识 Jetpack Compose</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" href="/docs/elements/alertdialog">基础组件</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" href="/docs/layout/box">布局组件</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link hasHref_VCh3" href="/docs/category/设计">设计</a><button aria-label="Toggle the collapsible sidebar category &#x27;设计&#x27;" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link hasHref_VCh3" tabindex="0" href="/docs/category/动画animation">动画（Animation）</a><button aria-label="Toggle the collapsible sidebar category &#x27;动画（Animation）&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link hasHref_VCh3" tabindex="0" href="/docs/category/主题theming">主题（Theming）</a><button aria-label="Toggle the collapsible sidebar category &#x27;主题（Theming）&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link hasHref_VCh3" tabindex="0" href="/docs/category/手势gesture">手势（Gesture）</a><button aria-label="Toggle the collapsible sidebar category &#x27;手势（Gesture）&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link hasHref_VCh3" tabindex="0" href="/docs/category/列表lists">列表（Lists）</a><button aria-label="Toggle the collapsible sidebar category &#x27;列表（Lists）&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link hasHref_VCh3" tabindex="0" href="/docs/category/图形graphics">图形（Graphics）</a><button aria-label="Toggle the collapsible sidebar category &#x27;图形（Graphics）&#x27;" type="button" class="clean-btn menu__caret"></button></div></li></ul></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/resources">资源</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--active hasHref_VCh3" aria-current="page" href="/docs/category/技术原理">技术原理</a><button aria-label="Toggle the collapsible sidebar category &#x27;技术原理&#x27;" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/principle/recompositionScope">了解 Compose 的重组作用域</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/principle/snapshot">透过 Snapshot 看重组</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/principle/recomposeWorkingPrinciple">重组的工作流程</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/principle/gapBuffer">Compose 运行原理与 GapBuffer</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/principle/modifierStructure">图解 Modifier</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/principle/composeAnnotation">Compose 注解到底做了什么？</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/principle/composeRemoteImage">如何为Compose Image提供网络图片加载支持</a></li></ul></li></ul></nav></div></aside><main class="docMainContainer_TCnq"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_DM6M"><div class="docItemContainer_vinB"><article><div class="tocCollapsible_jdIR theme-doc-toc-mobile tocMobile_TmEX"><button type="button" class="clean-btn tocCollapsibleButton_Fzxq">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>重组的工作流程</h1></header><p>我们都知道 Jetpack Compose 是一套声明式 UI 系统，当 UI 组件所依赖的状态发生改变时会自动发生重绘刷新，这个过程被官方称作<strong>重组</strong>，前面已经总结过 <a href="/docs/principle/recompositionScope/">Compose 的重组范围</a>，以及 <a href="/docs/principle/snapshot/">重组过程使用的Snapshot</a>。本文将带领大家来看看 Compose 源码中从状态更新到 recompose 过程在源码中是如何进行的，并且讲解快照系统在 recompose 过程中如何被使用到的。</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="意义">意义<a class="hash-link" href="#意义" title="Direct link to heading">​</a></h2><p>本文通过阅读源码来解读 recompose 流程，阅读源码其实是一个非常枯燥的过程，源码中存在着大量逻辑分支导致许多人看着看着就被绕晕了。本文剔除了所有与主线流程无关的逻辑分支，并结合配图进行逻辑表达，希望能够帮助大家理解 recompose 工作原理。通过这篇文章希望大家能够对 recompose工作原理产生一种感性认知，并在本文的基础上能够继续深入探索recompose流程中的各种技术细节。</p><p> ⚠️ Tips：由于 recompose 流程十分复杂，本文目前仅对 recompose 主线流程进行了描述，其中包含的许多技术细节没有深挖。由于本人采用动静结合方式进行源码分析，难免出现有些case流程没有覆盖到的情况，如果文章存在错误欢迎提出。</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="recompose-流程分析">recompose 流程分析<a class="hash-link" href="#recompose-流程分析" title="Direct link to heading">​</a></h2><h3 class="anchor anchorWithStickyNavbar_mojV" id="从-mutablestate-更新开始">从 MutableState 更新开始<a class="hash-link" href="#从-mutablestate-更新开始" title="Direct link to heading">​</a></h3><p>当你为 MutableState 赋值时将会默认调用 MutableState 的扩展方法 <code>MutableState.setValue</code> </p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">// androidx.compose.runtime.SnapshotState</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">inline operator fun &lt;T&gt; MutableState&lt;T&gt;.setValue(thisObj: Any?, property: KProperty&lt;*&gt;, value: T) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.value = value</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>通过查看 <code>mutableStateOf</code> 源码我们可以发现 MutableState 实际上是一个 <code>SnapshotMutableStateImpl</code> 类型实例</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">// androidx.compose.runtime.SnapshotState</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fun &lt;T&gt; mutableStateOf(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    value: T,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    policy: SnapshotMutationPolicy&lt;T&gt; = structuralEqualityPolicy()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">): MutableState&lt;T&gt; = createSnapshotMutableState(value, policy)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// androidx.compose.runtime.ActualAndroid.android</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">internal actual fun &lt;T&gt; createSnapshotMutableState(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    value: T,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    policy: SnapshotMutationPolicy&lt;T&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">): SnapshotMutableState&lt;T&gt; = ParcelableSnapshotMutableState(value, policy)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// androidx.compose.runtime.ParcelableSnapshotMutableState</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">internal class ParcelableSnapshotMutableState&lt;T&gt;(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    value: T,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    policy: SnapshotMutationPolicy&lt;T&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">) : SnapshotMutableStateImpl&lt;T&gt;(value, policy), Parcelable </span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>当 <code>value</code> 属性发生改变时会调用这个属性的 setter ，当然如果读取状态时也会走 getter。</p><p>此时的next是个 <code>StateStateRecord</code> 实例，其真正记录着当前state状态信息(通过当前value的getter与setter就可以看出)。此时首先会对当前值和要更新的值根据规则进行diff判断。当确定发生改变时会调用到 StateStateRecord 的 overwritable 方法。</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">// androidx.compose.runtime.SnapshotState</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">internal open class SnapshotMutableStateImpl&lt;T&gt;(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    value: T,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    override val policy: SnapshotMutationPolicy&lt;T&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">) : StateObject, SnapshotMutableState&lt;T&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Suppress(&quot;UNCHECKED_CAST&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    override var value: T</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        get() = next.readable(this).value</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        set(value) = next.withCurrent {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (!policy.equivalent(it.value, value)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 此时的this还是当前SnapshotMutableStateImpl</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                next.overwritable(this, it) { </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  this.value = value // 此时的this指向的next，这部操作也就是更新next其中的value</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                } </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private var next: StateStateRecord&lt;T&gt; = StateStateRecord(value)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>接下来会通过 <code>Snapshot.current</code> 获取当前上下文中的 Snapshot，如果你对 mutableState 更新操作在异步执行代码块中，由于我们知道 Snapshot 是一个 ThreadLocal 此时会返回当前执行线程的 Snapshot，当若当前执行线程的 Snapshot 为空时默认返回 <code>GlobalSnapshot</code>，如果你对 mutableState 更新操作直接在 Composable 中，当前 Composable 执行线程的 Snapshot 就是 <code>MutableSnapshot</code>。这将会影响到后续 recompose 的执行流程。</p><p> ⚠️ Tips：GlobalSnapshot 实际上是 MutableSnapShot 的子类</p><img src="/assets/images/demo1-e395e884114b85356f600b519382676d.png"><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">// androidx.compose.runtime.snapshots.Snapshot</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">internal inline fun &lt;T : StateRecord, R&gt; T.overwritable(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    state: StateObject,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    candidate: T,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    block: T.() -&gt; R</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">): R {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    var snapshot: Snapshot = snapshotInitializer</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return sync {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        snapshot = Snapshot.current</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.overwritableRecord(state, snapshot, candidate).block() // 更新 next</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }.also {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        notifyWrite(snapshot, state) // 写入通知</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>我们进入 <code>overwritableRecord </code> 看看其中做了什么，注意此时 state 其实是 mutableState。在这其中通过 <code>recordModified</code> 方法记录了修改。我们可以看到此时将当前修改的 state 添加到当前 Snapshot 的 modified 中了，这个后续会用到的。</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">// androidx.compose.runtime.snapshots.Snapshot</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">internal fun &lt;T : StateRecord&gt; T.overwritableRecord(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    state: StateObject,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    snapshot: Snapshot,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    candidate: T</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">): T {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (snapshot.readOnly) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        snapshot.recordModified(state)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    val id = snapshot.id</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (candidate.snapshotId == id) return candidate</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    val newData = newOverwritableRecord(state, snapshot)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    newData.snapshotId = id</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    snapshot.recordModified(state) // 记录修改</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return newData</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// androidx.compose.runtime.snapshots.Snapshot</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">override fun recordModified(state: StateObject) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (modified ?: HashSet&lt;StateObject&gt;().also { modified = it }).add(state)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>可能你对 mutableState 更新操作是否在 ComposeScope 中而感到困惑，举个例子其实就明白了。recompose 能够执行到就在 ComposeScope 中，不能执行到就不在 ComposeScope 中。</p><p>这个在后面 <a href="#takemutablesnapshot"><strong><em>takeMutableSnapshot读观察者与写观察者</em></strong> </a> 部分是会进行解释。</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">var display by mutableStateOf(&quot;Init&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Preview</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Composable</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fun Demo() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Text (</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        text = display,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fontSize = 50.sp,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        modifier = Modifier.clickable {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            display = &quot;change&quot; // recompose不能执行到，此时是 GlobalSnapshot</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    display = &quot;change&quot; // recompose能够执行到，此时是 MutableSnapShot</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>接下来就是通过 <code>notifyWrite</code> 执行事件通知此时可以看到调用了写观察者 <code>writeObserver</code> 。</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">// androidx.compose.runtime.snapshots.Snapshot</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@PublishedApi</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">internal fun notifyWrite(snapshot: Snapshot, state: StateObject) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    snapshot.writeObserver?.invoke(state)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>此时会根据当前 Snapshot 不同而调用到不同的写观察者 <code>writeObserver</code> 。</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="globalsnapshot-写入通知">GlobalSnapshot 写入通知<a class="hash-link" href="#globalsnapshot-写入通知" title="Direct link to heading">​</a></h3><p>全局的写入观察者是在 <code>setContent</code> 时就进行了注册， 此时会回调 registerGlobalWriteObserver 的尾lambda，可以看到这里就一个channel (没错就是Kotlin协程那个热数据通道Channel)，我门可以看到很容易看到在上方以AndroidUiDispatcher.Main 作为调度器的 CoroutineScope 中进行了挂起等待消费，所以执行流程自然会进到了 <code>sendApplyNotifications()</code> 。 （AndroidUiDispatcher.Main 与 Choreographer 息息相关，篇幅有限就不展开讨论了，有兴趣可以自己去跟源码）</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">internal object GlobalSnapshotManager {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private val started = AtomicBoolean(false)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fun ensureStarted() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (started.compareAndSet(false, true)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            val channel = Channel&lt;Unit&gt;(Channel.CONFLATED)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            CoroutineScope(AndroidUiDispatcher.Main).launch {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                channel.consumeEach {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    Snapshot.sendApplyNotifications()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Snapshot.registerGlobalWriteObserver {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                channel.offer(Unit)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h4 class="anchor anchorWithStickyNavbar_mojV" id="sendapplynotifications">sendApplyNotifications<a class="hash-link" href="#sendapplynotifications" title="Direct link to heading">​</a></h4><p>接下来，我们进入 <code>sendApplyNotifications()</code> 其中看看做了什么，可以看到这里使用我们前面提到的那个 <code>modified</code> ，当发生修改时 changes 必然为 true，所以接着会调用到 <code>advanceGlobalSnapshot</code></p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">// androidx.compose.runtime.snapshots.Snapshot</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fun sendApplyNotifications() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        val changes = sync {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            currentGlobalSnapshot.get().modified?.isNotEmpty() == true</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (changes)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            advanceGlobalSnapshot()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>我们继续往下跟下去走到了 <code>advanceGlobalSnapshot</code> ，此时将所有 <code>modified</code> 取出并便利调用 <code>applyObservers</code> 中包含的所有观察者。 </p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">// androidx.compose.runtime.snapshots.Snapshot</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private fun advanceGlobalSnapshot() = advanceGlobalSnapshot { }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private fun &lt;T&gt; advanceGlobalSnapshot(block: (invalid: SnapshotIdSet) -&gt; T): T {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    val previousGlobalSnapshot = currentGlobalSnapshot.get()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    val result = sync {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        takeNewGlobalSnapshot(previousGlobalSnapshot, block)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    val modified = previousGlobalSnapshot.modified</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (modified != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        val observers: List&lt;(Set&lt;Any&gt;, Snapshot) -&gt; Unit&gt; = sync { applyObservers.toMutableList() }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        observers.fastForEach { observer -&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            observer(modified, previousGlobalSnapshot)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ....</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return result</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h4 class="anchor anchorWithStickyNavbar_mojV" id="applyobservers之recompositionrunne">applyObservers之recompositionRunne<a class="hash-link" href="#applyobservers之recompositionrunne" title="Direct link to heading">​</a></h4><img src="/assets/images/demo2-1f4b6bb80982173559050b56e5455e1c.png"><p>据我调查此时 <code>applyObservers</code> 中包含的观察者仅有两个，一个是 <code>SnapshotStateObserver.applyObserver</code> 用来更新快照状态信息，另一个就是 <code>recompositionRunner</code> 用来处理 recompose流程 的。由于我们是在研究recompose 流程的所以就不分开去讨论了。我们来看看处理 recompose 的 observer 都做了什么，首先他将所有改变的 <code>mutableState</code> 添加到了 <code>snapshotInvalidations</code>，这个后续会用到。后面可以看到有一个resume，说明lambda的最后调用的 <code>deriveStateLocked</code> 返回了一个协程 Continuation 实例。使得挂起点位置恢复执行，所以我们进入<code>deriveStateLocked </code> 看看这个协程 Continuation 实例到底是谁。</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">// androidx.compose.runtime.Recomposer</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@OptIn(ExperimentalComposeApi::class)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private suspend fun recompositionRunner(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    block: suspend CoroutineScope.(parentFrameClock: MonotonicFrameClock) -&gt; Unit</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    withContext(broadcastFrameClock) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 负责处理 recompose 的 observer 就是他</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        val unregisterApplyObserver = Snapshot.registerApplyObserver { </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            changed, _ -&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                synchronized(stateLock) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    if (_state.value &gt;= State.Idle) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        snapshotInvalidations += changed</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        deriveStateLocked()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    } else null</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }?.resume(Unit)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ....</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>通过函数返回值可以看到这是一个可取消的Continuation实例 <code>workContinuation</code>，</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">// androidx.compose.runtime.Recomposer</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private fun deriveStateLocked(): CancellableContinuation&lt;Unit&gt;? {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ....</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return if (newState == State.PendingWork) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        workContinuation.also {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                workContinuation = null</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } else null</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>那这个workContinuation是在哪里赋值的呢，我们很容易就找到了其唯一被赋值的地方。此时 workContinuation 就是 co，此时resume也就是恢复执行 <code>awaitWorkAvailable</code> 调用挂起点。</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">// androidx.compose.runtime.Recomposer</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private suspend fun awaitWorkAvailable() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!hasSchedulingWork) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        suspendCancellableCoroutine&lt;Unit&gt; { co -&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            synchronized(stateLock) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (hasSchedulingWork) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    co.resume(Unit)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    workContinuation = co</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h4 class="anchor anchorWithStickyNavbar_mojV" id="runrecomposeandapplychanges-三步骤">runRecomposeAndApplyChanges 三步骤<a class="hash-link" href="#runrecomposeandapplychanges-三步骤" title="Direct link to heading">​</a></h4><p>我们可以找到在 <code>runRecomposeAndApplyChanges</code> 中调用 <code>awaitWorkAvailable</code> 而产生了挂起，所以此时会恢复调用 <code>runRecomposeAndApplyChanges</code> ，这里主要有三步操作接下来进行介绍</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">// androidx.compose.runtime.Recomposer</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">suspend fun runRecomposeAndApplyChanges() = recompositionRunner { parentFrameClock -&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    val toRecompose = mutableListOf&lt;ControlledComposition&gt;()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    val toApply = mutableListOf&lt;ControlledComposition&gt;()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    while (shouldKeepRecomposing) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        awaitWorkAvailable()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 从这开始恢复执行</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            synchronized(stateLock) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (!hasFrameWorkLocked) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 步骤1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    recordComposerModificationsLocked()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    !hasFrameWorkLocked</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                } else false</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ) continue</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 等待Vsync信号，类似于传统View系统中scheduleTraversals?</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        parentFrameClock.withFrameNanos { frameTime -&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            trace(&quot;Recomposer:recompose&quot;) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                synchronized(stateLock) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    recordComposerModificationsLocked()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                        // 步骤2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    compositionInvalidations.fastForEach { toRecompose += it }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    compositionInvalidations.clear()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">              </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                val modifiedValues = IdentityArraySet&lt;Any&gt;()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                val alreadyComposed = IdentityArraySet&lt;ControlledComposition&gt;()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                while (toRecompose.isNotEmpty()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        toRecompose.fastForEach { composition -&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            alreadyComposed.add(composition)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            // 步骤3</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            performRecompose(composition, modifiedValues)?.let {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                toApply += it</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    } finally {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        toRecompose.clear()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    ....</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                ....</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>对于这三个步骤，我们分别来看首先是步骤1调用了 <code>recordComposerModificationsLocked</code> 方法， 还记得 <code>snapshotInvalidations</code> 嘛, 他记录着所有更改的 mutableState，此时回调所有已知composition的<code>recordModificationsOf</code> 方法。</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">// androidx.compose.runtime.Recomposer</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private fun recordComposerModificationsLocked() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (snapshotInvalidations.isNotEmpty()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        snapshotInvalidations.fastForEach { changes -&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            knownCompositions.fastForEach { composition -&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                composition.recordModificationsOf(changes)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        snapshotInvalidations.clear()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (deriveStateLocked() != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            error(&quot;called outside of runRecomposeAndApplyChanges&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>经过一系列调用会将所有依赖当前 mutableState 的所有 Composable Scope 存入到 <code>compositionInvalidations</code> 这个 List 中。</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">// androidx.compose.runtime.Recomposer</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">internal override fun invalidate(composition: ControlledComposition) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    synchronized(stateLock) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (composition !in compositionInvalidations) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            compositionInvalidations += composition</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            deriveStateLocked()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else null</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }?.resume(Unit)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>步骤2就很简单了，将 compositionInvalidations 的所有元素转移到了 toRecompose，而步骤3则是 recompose的重中之重，通过 <code>performRecompose</code> 使所有受到影响的 Composable Scope 重新执行。</p><h4 class="anchor anchorWithStickyNavbar_mojV" id="performrecompose">performRecompose<a class="hash-link" href="#performrecompose" title="Direct link to heading">​</a></h4><p>我们可以看到 <code>performRecompose</code> 中间接调用了 <code>composing</code> ，而其中最关键 <code>recompose</code> 也在回调中完成，那么我们需要再进入 <code>composing</code> 看看什么时候会回调。</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">// androidx.compose.runtime.Recomposer</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private fun performRecompose(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    composition: ControlledComposition,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    modifiedValues: IdentityArraySet&lt;Any&gt;?</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">): ControlledComposition? {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (composition.isComposing || composition.isDisposed) return null</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return if (</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        composing(composition, modifiedValues) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (modifiedValues?.isNotEmpty() == true) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                composition.prepareCompose {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    modifiedValues.forEach { composition.recordWriteOf(it) }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            composition.recompose() // 真正发生recompose的地方</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ) composition else null</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p> <code>composing</code> 内部首先拍摄了一次快照，然后将我们的recompose过程在这次快照中执行，最后进行了apply。又关于快照系统的讲解详见 <a href="https://juejin.cn/post/6972692477505437733" target="_blank" rel="noopener noreferrer">《Jetpack Compose · 快照系统》</a>。 </p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">// androidx.compose.runtime.Recomposer</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private inline fun &lt;T&gt; composing(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  composition: ControlledComposition,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  modifiedValues: IdentityArraySet&lt;Any&gt;?,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  block: () -&gt; T</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">): T {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  val snapshot = Snapshot.takeMutableSnapshot(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    readObserverOf(composition), writeObserverOf(composition, modifiedValues)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return snapshot.enter(block)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  } finally {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    applyAndCheck(snapshot)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h4 class="anchor anchorWithStickyNavbar_mojV" id="takemutablesnapshot-读观察者与写观察者">takeMutableSnapshot 读观察者与写观察者<a class="hash-link" href="#takemutablesnapshot-读观察者与写观察者" title="Direct link to heading">​</a></h4><img src="/assets/images/demo3-bc90ce4942b1404bfe6707c714d052ca.png"><p>值得注意的是此时调用的 <code>takeMutableSnapshot</code> 方法同时传入了一个读观察者和写观察者，而这两个观察者在什么时机回调呢？当我们每次 recompose 时都会拍摄一次快照，然后我们的重新执行过程在这次快照中执行，在重新执行过程中如果出现了 mutableState 的读取或写入操作都会相应的回调这里的读观察者和写观察者。也就说明每次recompose都会进行重新一次绑定。 读观察者回调时机比较好理解，写观察者在什么时机回调呢？ 还记得我们刚开始说的 <code>GlobalSnapshot</code> 和 <code>MutableSnapshot</code> 嘛？</p><p>到这里我们一直都在分析 <code>GlobalSnapshot</code> 这条执行过程，通过调用 <code>takeMutableSnapshot</code> 将返回一个 <code>MutableSnapshot</code> 实例，我们的recompose重新执行过程发生在当前<code>MutableSnapshot</code> 实例的<code>enter</code> 方法中，此时重新执行过程中通过调用<code>Snapshot.current  </code>将返回当前<code>MutableSnapshot</code> 实例，所以重新执行过程中发生的写操作就会回调 <code>takeMutableSnapshot</code> 所传入的写观察者。也就是以下这种情况，当 Demo 发生recompose时 display所在 Snapshot 就是拍摄的<code>MutableSnapshot</code> 快照。</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">var display by mutableStateOf(&quot;Init&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Preview</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Composable</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fun Demo() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Text (</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        text = display,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fontSize = 50.sp</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    display = &quot;change&quot; // recompose能够执行到，此时是 MutableSnapShot</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h3 class="anchor anchorWithStickyNavbar_mojV" id="mutablesnapshot-写入通知">MutableSnapshot 写入通知<a class="hash-link" href="#mutablesnapshot-写入通知" title="Direct link to heading">​</a></h3><p>接下来，我们来看看 <code>takeMutableSnapshot</code> 的写观察者是如何实现的。此时会将更新的值传入当前recompose composition 的 <code>recordWriteOf</code> 方法。</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">// androidx.compose.runtime.Recomposer</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private fun writeObserverOf(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    composition: ControlledComposition,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    modifiedValues: IdentityArraySet&lt;Any&gt;?</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">): (Any) -&gt; Unit {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return { value -&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        composition.recordWriteOf(value)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        modifiedValues?.add(value)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>通过对于流程分析发现，实际上在recompose过程中进行状态写入操作时，并不会通过写观察者立即进行recompose 过程，而是等待到当前recompose过程结束后进行 apply 时再进行重新 recompose。</p><h4 class="anchor anchorWithStickyNavbar_mojV" id="applyandcheck">applyAndCheck<a class="hash-link" href="#applyandcheck" title="Direct link to heading">​</a></h4><p>让我们回到Recomposer的 <code>composing</code> 方法，我们通过 <code>applyAndCheck</code> 完成后续 apply 操作。<code>applyAndCheck</code> 内部使用了 <code>MutableSnapshot.apply</code></p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">// androidx.compose.runtime.Recomposer</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private inline fun &lt;T&gt; composing(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    composition: ControlledComposition,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    modifiedValues: IdentityArraySet&lt;Any&gt;?,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    block: () -&gt; T</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">): T {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    val snapshot = Snapshot.takeMutableSnapshot(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        readObserverOf(composition), writeObserverOf(composition, modifiedValues)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return snapshot.enter(block)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } finally {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        applyAndCheck(snapshot) // 在这里</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private fun applyAndCheck(snapshot: MutableSnapshot) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    val applyResult = snapshot.apply()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (applyResult is SnapshotApplyResult.Failure) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        error(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            &quot;Unsupported concurrent change during composition. A state object was &quot; +</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                &quot;modified by composition as well as being modified outside composition.&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h4 class="anchor anchorWithStickyNavbar_mojV" id="apply中使用的applyobservers">apply中使用的applyObservers<a class="hash-link" href="#apply中使用的applyobservers" title="Direct link to heading">​</a></h4><p>我们再进入<code>MutableSnapshot.apply</code> 一探究竟，此时将当前 modified 在 <code>snapshot.recordModified(state)</code> 已经更新过了，忘记的话可以回头看看，前面已经讲过了。此时仍然使用了 <code>applyObservers</code> 进行遍历通知。这个<code>applyObservers</code> 其实是个静态变量，所以不同的 GlobalSnapshot 与MutableSnapshot 可以共享，接下来仍然通过预先订阅好的 <code>recompositionRunner</code> 用来处理 recompose 过程，详见 <a href="#applyobserversrecompositionrunne"><strong><em>applyObservers之recompositionRunner</em></strong></a>，接下来的recompose流程就完全相同了。</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">// androidx.compose.runtime.snapshots.Snapshot</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">open fun apply(): SnapshotApplyResult {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    val modified = modified</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ....</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    val (observers, globalModified) = sync {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        validateOpen(this)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (modified == null || modified.size == 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ....</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ....</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            applyObservers.toMutableList() to globalModified</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ....</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (modified != null &amp;&amp; modified.isNotEmpty()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        observers.fastForEach {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            it(modified, this)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return SnapshotApplyResult.Success</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/milklabdev/jetpack-compose-book/tree/master/docs/principle/recomposeWorkingPrinciple.mdx" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_dcUD" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_foO9"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/docs/principle/snapshot"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">透过 Snapshot 看重组</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/docs/principle/gapBuffer"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Compose 运行原理与 GapBuffer</div></a></div></nav></div></div><div class="col col--3"><div class="tableOfContents_cNA8 thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#意义" class="table-of-contents__link toc-highlight">意义</a></li><li><a href="#recompose-流程分析" class="table-of-contents__link toc-highlight">recompose 流程分析</a><ul><li><a href="#从-mutablestate-更新开始" class="table-of-contents__link toc-highlight">从 MutableState 更新开始</a></li><li><a href="#globalsnapshot-写入通知" class="table-of-contents__link toc-highlight">GlobalSnapshot 写入通知</a></li><li><a href="#mutablesnapshot-写入通知" class="table-of-contents__link toc-highlight">MutableSnapshot 写入通知</a></li></ul></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">社区</div><ul class="footer__items"><li class="footer__item"><a href="https://github.com/milklabdev" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Github<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2022 Milk Lab, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.8d46e49c.js"></script>
<script src="/assets/js/main.4fa214f8.js"></script>
</body>
</html>