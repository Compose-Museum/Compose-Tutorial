<!doctype html>
<html class="docs-version-current" lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.15">
<title data-react-helmet="true">图解 Modifier | 你好 Compose</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:url" content="https://jetpackcompose.cn/docs/principle/modifierStructure"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="图解 Modifier | 你好 Compose"><meta data-react-helmet="true" name="description" content="想必许多小伙伴在使用 Jetpack Compose 开发时都使用过 Modifier 来修饰 UI 组件，做过一段时间 Compose 开发的小伙伴都会发现 UI 组件最终所呈现效果与 Modifier 调用顺序是息息相关的。这是因为 Modifier 会由于调用顺序的不同而产生不同的 Modifier 链，Jetpack Compose 会按照 Modifier 链上的顺序进行执行，从而导致 Modifier 调用顺序不同时，UI 组件最终呈现的效果也会不同。那么 Modifier 链在底层如何存储的呢？本文将带着大家来一起扒一扒 Modifier 实现原理，结合图片来解释 Modifier 链的底层数据结构。"><meta data-react-helmet="true" property="og:description" content="想必许多小伙伴在使用 Jetpack Compose 开发时都使用过 Modifier 来修饰 UI 组件，做过一段时间 Compose 开发的小伙伴都会发现 UI 组件最终所呈现效果与 Modifier 调用顺序是息息相关的。这是因为 Modifier 会由于调用顺序的不同而产生不同的 Modifier 链，Jetpack Compose 会按照 Modifier 链上的顺序进行执行，从而导致 Modifier 调用顺序不同时，UI 组件最终呈现的效果也会不同。那么 Modifier 链在底层如何存储的呢？本文将带着大家来一起扒一扒 Modifier 实现原理，结合图片来解释 Modifier 链的底层数据结构。"><link data-react-helmet="true" rel="icon" href="/img/logo.svg"><link data-react-helmet="true" rel="canonical" href="https://jetpackcompose.cn/docs/principle/modifierStructure"><link data-react-helmet="true" rel="alternate" href="https://jetpackcompose.cn/docs/principle/modifierStructure" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://jetpackcompose.cn/docs/principle/modifierStructure" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.cba56bc1.css">
<link rel="preload" href="/assets/js/runtime~main.3ebcbd4b.js" as="script">
<link rel="preload" href="/assets/js/main.50fd7d2b.js" as="script">
</head>
<body data-theme="light">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region"><a href="#" class="skipToContent_ZgBM">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_W2Cr themedImage--light_TfLj"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_W2Cr themedImage--dark_oUvU"></div><b class="navbar__title">Jetpack Compose 博物馆</b></a><a class="navbar__item navbar__link navbar__link--active" href="/docs/">文档</a><a class="navbar__item navbar__link" href="/docs/open-source-project/compose-douban">开源项目</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/compose-museum/jetpack-compose-book" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><div class="toggle_Pssr toggle_TdHA toggleDisabled_jDku"><div class="toggleTrack_SSoT" role="button" tabindex="-1"><div class="toggleTrackCheck_XobZ"><span class="toggleIcon_eZtF">🌜</span></div><div class="toggleTrackX_YkSC"><span class="toggleIcon_eZtF">🌞</span></div><div class="toggleTrackThumb_uRm4"></div></div><input type="checkbox" class="toggleScreenReader_JnkT" aria-label="Switch between dark and light mode"></div><div class="dsla-search-wrapper"><div class="dsla-search-field" data-tags="default,docs-default-current"></div></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docs-wrapper docs-doc-page"><div class="docPage_P2Lg"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_RiI4" type="button"></button><aside class="theme-doc-sidebar-container docSidebarContainer_rKC_"><div class="sidebar_CW9Y"><nav class="menu thin-scrollbar menu_SkdO"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/">写在开头</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link hasHref_VCh3" href="/docs/category/入门">入门</a><button aria-label="Toggle the collapsible sidebar category &#x27;入门&#x27;" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/installation">安装或更新 Android Studio</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/tutorial">初识 Jetpack Compose</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" href="/docs/elements/alertdialog">基础组件</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_VCh3" href="/docs/layout/box">布局组件</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link hasHref_VCh3" href="/docs/category/设计">设计</a><button aria-label="Toggle the collapsible sidebar category &#x27;设计&#x27;" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link hasHref_VCh3" tabindex="0" href="/docs/category/动画animation">动画（Animation）</a><button aria-label="Toggle the collapsible sidebar category &#x27;动画（Animation）&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link hasHref_VCh3" tabindex="0" href="/docs/category/主题theming">主题（Theming）</a><button aria-label="Toggle the collapsible sidebar category &#x27;主题（Theming）&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link hasHref_VCh3" tabindex="0" href="/docs/category/手势gesture">手势（Gesture）</a><button aria-label="Toggle the collapsible sidebar category &#x27;手势（Gesture）&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link hasHref_VCh3" tabindex="0" href="/docs/category/列表lists">列表（Lists）</a><button aria-label="Toggle the collapsible sidebar category &#x27;列表（Lists）&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link hasHref_VCh3" tabindex="0" href="/docs/category/图形graphics">图形（Graphics）</a><button aria-label="Toggle the collapsible sidebar category &#x27;图形（Graphics）&#x27;" type="button" class="clean-btn menu__caret"></button></div></li></ul></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/resources">资源</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--active hasHref_VCh3" aria-current="page" href="/docs/category/技术原理">技术原理</a><button aria-label="Toggle the collapsible sidebar category &#x27;技术原理&#x27;" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/principle/recompositionScope">了解 Compose 的重组作用域</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/principle/snapshot">透过 Snapshot 看重组</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/principle/recomposeWorkingPrinciple">重组的工作流程</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/principle/gapBuffer">Compose 运行原理与 GapBuffer</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/principle/modifierStructure">图解 Modifier</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/principle/composeAnnotation">Compose 注解到底做了什么？</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/principle/composeRemoteImage">如何为Compose Image提供网络图片加载支持</a></li></ul></li></ul></nav></div></aside><main class="docMainContainer_TCnq"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_DM6M"><div class="docItemContainer_vinB"><article><div class="tocCollapsible_jdIR theme-doc-toc-mobile tocMobile_TmEX"><button type="button" class="clean-btn tocCollapsibleButton_Fzxq">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>图解 Modifier</h1></header><p>想必许多小伙伴在使用 Jetpack Compose 开发时都使用过 Modifier 来修饰 UI 组件，做过一段时间 Compose 开发的小伙伴都会发现 UI 组件最终所呈现效果与 Modifier 调用顺序是息息相关的。这是因为 Modifier 会由于调用顺序的不同而产生不同的 Modifier 链，Jetpack Compose 会按照 Modifier 链上的顺序进行执行，从而导致 Modifier 调用顺序不同时，UI 组件最终呈现的效果也会不同。那么 Modifier 链在底层如何存储的呢？本文将带着大家来一起扒一扒 Modifier 实现原理，结合图片来解释 Modifier 链的底层数据结构。</p><div align="center"><img src="/assets/images/demo1-022d804c834595afdb8d6fa59ff78601.png" width="50%" height="50%"></div><h2 class="anchor anchorWithStickyNavbar_mojV" id="modifier-接口">Modifier 接口<a class="hash-link" href="#modifier-接口" title="Direct link to heading">​</a></h2><div align="center"><img src="/assets/images/demo2-1f6dd54b4b19d92b802dbeb89d69a873.png" width="50%" height="50%"></div><p>从源码中，我们可以发现 Modifier 实际上是个接口。</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">interface Modifier { </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fun &lt;R&gt; foldIn(initial: R, operation: (R, Element) -&gt; R): R</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fun &lt;R&gt; foldOut(initial: R, operation: (Element, R) -&gt; R): R</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fun any(predicate: (Element) -&gt; Boolean): Boolean</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fun all(predicate: (Element) -&gt; Boolean): Boolean</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    infix fun then(other: Modifier): Modifier = ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    interface Element : Modifier {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    companion object : Modifier {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ... </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>既然是接口肯定有其对应的实现。Modifier 接口有三个直接实现类或接口：伴生对象 Modifier、内部子接口Modifier.Element、CombinedModifier。</p><p><strong>伴生对象 Modifier：</strong>最常用的 Modifier， 当我们在代码中使用 Modifier.xxx()，实际使用的就是这个伴生对象。</p><p><strong>内部子接口 Modifier.Element：</strong>当我们使用Modifier.xxx()时，其内部实际会创建一个 Modifier 实例。我们以 size 为例。当我们使用 <code>Modifier.size(100.dp)</code> 时，实际上内部会创建一个 <code>SizeModifier</code> 实例</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">fun Modifier.size(size: Dp) = this.then(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    SizeModifier(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>从源码中，我们可以发现 SizeModifier 实现了LayoutModifier 接口，而 LayoutModifier 接口又是 Modifier.Element 的子接口。</p><div align="center"><img src="/assets/images/demo3-14c9dae20e7c50bd067f18d26113d624.png" width="50%" height="50%"></div><p>可以说，当我们使用 Modifier.xxx() 所创建的各类 Modifier 追踪溯源，最后发现其实都是 Modifier.Element 子类。当我们使用 <code>Modifier.size()</code> 所创建的 SizeModifier 实际上是 Modifier 接口的直接子接口 <code>LayoutModifier</code> 的子类，像这类直接子接口或子类还有哪些呢，在这里我整理了一下。如图所示，这些接口基本涵盖了 Modifier 所提供的所有能力。</p><div align="center"><img src="/assets/images/demo4-bc457313a0be978d46c7675aea4da2cc.png" width="50%" height="50%"></div><p><strong>CombinedModifier：</strong> Compose内部维护的数据结构，用于连接 Modifier 链中的每个 Modifier 结点，后续会讲到。</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="modifier-链的构建过程">Modifier 链的构建过程<a class="hash-link" href="#modifier-链的构建过程" title="Direct link to heading">​</a></h2><p>接下来，我们通过实例来分析 Modifier 链是如何一步步创建的。</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="then">then()<a class="hash-link" href="#then" title="Direct link to heading">​</a></h3><p>一般我们会在代码中通过伴生对象 Modifier 来创建 Modifier 链。前文提到过，当我们使用 <code>Modifier.size()</code> 时会创建一个 SizeModifier 实例。我们进入 <code>size()</code> 实现会发现 SizeModifier实例被当作参数传入 <code>then() </code>方法中。而这个 <code>then()</code> 方法就是 Modifier 间相互连接的关键方法。</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">Modifier</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .size(100.dp)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fun Modifier.size(size: Dp) = this.then( // 关键方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    SizeModifier(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>此时 <code>this</code> 指针仍指向的是我们的伴生对象 Modifier，所以我们看看伴生对象 Modifier 是如何实现 <code>then()</code> 方法的。 可以看到伴生对象 Modifier 的 <code>then() </code>方法实现的十分干脆，直接返回待连接的 SizeModifier。</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">companion object : Modifier {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    override infix fun then(other: Modifier): Modifier = other</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>此时Modifier链的数据结构如下</p><div align="center"><img src="/assets/images/demo5-4a8cdd16ea302e5a5f911e56f0bf7dd3.png" width="50%" height="50%"></div><p>接下来，我们继续调用 <code>Modifier.background(Color.Red)</code>。由于是链式调用，此时当前 Modifier 是 SizeModifier，也就是说我们调用 background 时，其内部使用的 <code>this</code> 指针指向的是 SizeModifier 实例。</p><p>从源码我们可以看出，Background 实际上 <code>DrawModifier</code> 的实现类，同时也是 <code>Modifier.Element</code> 接口的实现类</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">Modifier</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .size(100.dp)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .background(Color.Red)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fun Modifier.background(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    color: Color,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    shape: Shape = RectangleShape</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">) = this.then( // 当前 this 指向 SizeModifier 实例</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Background(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>我们向上查找 SizeModifier 的 <code>then</code> 方法实现，最终在 <code>Modifier</code> 接口中找到了。此时，我们原有 SizeModifier 会通过一个 CombinedModifier 连接 Background</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">interface Modifier {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    infix fun then(other: Modifier): Modifier =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (other === Modifier) this else CombinedModifier(this, other)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class CombinedModifier(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private val outer: Modifier,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private val inner: Modifier</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">) : Modifier</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>此时 Modifier 链的数据结构如下</p><div align="center"><img src="/assets/images/demo6-06d95cde98bdb133b519696c03faa2d1.png" width="50%" height="50%"></div><p>我们通过图片可以直观查看 CombinedModifier 通过 outer 与 inner 连接了两个 Modifier。<strong>然而值得注意的是 outer 与 inner 字段都被使用 private 关键字声明，意味着不希望被外部拿到。</strong> Modifier 链既然以链式结构存储，官方又使用了 private 关键字声明，难道不允许我们遍历 Modifier 链嘛。其实官方早就替我们想好了，通过 <strong>foldOut()</strong> 与 <strong>foldIn()</strong>，有关于这部分内容我们马上就会讲到。</p><p>我们继续调用 <code>Modifier.padding(10.dp)</code>，此时 padding 内部使用的 <code>this</code> 指针指向的是 CombinedModifier 实例，我们翻阅 CombinedModifier 的 <code>then</code> 方法实现发生没有重写，最终还是回到了 <code>Modifier</code> 接口中。</p><p>此时待连接的实际上是一个 PaddingModifier 实例。</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">Modifier</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .size(100.dp)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .background(Color.Red)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .padding(10.dp)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fun Modifier.padding(all: Dp) =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.then(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        PaddingModifier(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    )</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>此时Modifier链的数据结构如下</p><div align="center"><img src="/assets/images/demo7-713f58b953a14cf4216d33a0649a8cc3.png" width="50%" height="50%"></div><h3 class="anchor anchorWithStickyNavbar_mojV" id="composed">composed()<a class="hash-link" href="#composed" title="Direct link to heading">​</a></h3><p>接下来我们想要添加一些手势监听，我们通常会使用 <code>Modifier.pointerInput()</code> 来定制手势处理。从源码中我们可以发现此时并没有使用 <code>then()</code> 方法连接 Modifier，而使用的是 <code>composed()</code> 方法。从 <code>composed()</code> 实现中我们可以看到最终仍然使用的是 <code>then()</code> 方法，此时待连接的是个 <code>ComposedModifier</code> 实例。然而我们知道其实我们真正要连接的实际上应该是手势处理相关Modifier，通过  <code>composed()</code> 方法参数我们可以得知，此时实际上 <code>ComposedModifier </code>内部持有了一个工厂 lambda 用于生产 Modifier 的，而真正要被连接的 Modifier 实际上就是工厂 lambda 的返回值 SuspendingPointerInputFilter。SuspendingPointerInputFilter 实际上是 PointerInputModifier 的实现类。而 ComposedModifier 实际上就是做了一个装箱过程。然而什么时候拆箱呢？这个我们后续会讲到的。</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">Modifier</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .size(100.dp)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .background(Color.Red)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .padding(10.dp)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .pointerInput(Unit) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fun Modifier.pointerInput(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    key1: Any?,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    block: suspend PointerInputScope.() -&gt; Unit</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">): Modifier = composed( //</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // SuspendingPointerInputFilter 是手势处理的真正Modifier</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    remember(density) { SuspendingPointerInputFilter(viewConfiguration, density) }.apply {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fun Modifier.composed(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    inspectorInfo: InspectorInfo.() -&gt; Unit = NoInspectorInfo,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    factory: @Composable Modifier.() -&gt; Modifier</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">): Modifier = this.then(ComposedModifier(inspectorInfo, factory))</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>此时 Modifier 链的数据结构如下</p><div align="center"><img src="/assets/images/demo8-f1453c8f2f3121e850a7b515687d2ea1.png" width="50%" height="50%"></div><p>以此类推，调用方法越多Modifier 链就会变得越长。</p><div align="center"><img src="/assets/images/demo9-766bf44e266203dd57a86fdc0ba192ef.png" width="50%" height="50%"></div><h2 class="anchor anchorWithStickyNavbar_mojV" id="modifier-链的遍历">Modifier 链的遍历<a class="hash-link" href="#modifier-链的遍历" title="Direct link to heading">​</a></h2><h3 class="anchor anchorWithStickyNavbar_mojV" id="foldin-与-foldout-用法">foldIn() 与 foldOut() 用法<a class="hash-link" href="#foldin-与-foldout-用法" title="Direct link to heading">​</a></h3><p>Modifier 链既然是链式结构，说明是可以遍历的。然而前文我们也提到过， outer 与 inner 字段都被使用 private 关键字声明，意味着外部是拿不到的。所以，官方为我们提供了 <strong>foldOut()</strong> 与 <strong>foldIn()</strong> 专门用来遍历 Modifier 链。</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">Modifier</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .size(100.dp)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .background(Color.Red)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .padding(10.dp)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .pointerInput(Unit) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p><strong>foldIn()：</strong> 正向遍历 Modifier 链，SizeModifier-&gt; Background -&gt; PaddingModifier -&gt; ComposedModifier</p><p><strong>foldOut()：</strong> 反向遍历 Modifier 链, ComposedModifier -&gt; PaddingModifier -&gt; Background -&gt;SizeModifier</p><p>当然 <strong>foldOut()</strong> 与 <strong>foldIn()</strong>  是需要传递参数的。这里涉及到两个参数 initial, operation。</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">fun &lt;R&gt; foldIn(initial: R, operation: (R, Element) -&gt; R): R</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fun &lt;R&gt; foldOut(initial: R, operation: (Element, R) -&gt; R): R</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>initial：初始值</p><p>operation：每遍历到一个 Modifier 时的回调，这个 lambda 又有两个参数，R类型与 Element类型</p><p>为解释这两个参数的意义，我觉得用 for 循环类比比较恰当。</p><p>foldIn 方法类似于 <code>for (int i = initial;  ; operation())</code> 。 设置 initial 参数类似为 i 设置初始值，而 operation 返回值将作为值的更新。</p><p>foldOut 方法与之类似，只不过遍历顺序相反。</p><p>也就是说遍历当前 Modifier 时执行的operation 的返回值将作为链中下一个 Modifier 的 operation 的 R 类型参数传入。这么说可能比较晦涩难懂，在这里简单举个例子，比如说我们希望统计 Modifier 链中有 Modifier 的数量。</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">val modifier = Modifier</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .size(100.dp)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .background(Color.Red)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .padding(10.dp)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .pointerInput(Unit) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">val result = modifier.foldIn&lt;Int&gt;(0) { currentIndex, element -&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Log.d(&quot;compose_study&quot;, &quot;index: $currentIndex , element :$element&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    currentIndex + 1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>foldOut 方法的方法也是类似，大家都简单理解为反向遍历 Modifier 链即可。</p><p>到这里大家可能心生疑问，我们前面所讲的 Modifier 链中不仅仅只有 Modifier.Element，其中还夹杂着许多 CombinedModifier。为什么我们遍历 Modifier 链时这些 CombinedModifier 没有出现呢？原因在于CombinedModifier 实际上是 Compose 内部维护的数据结构，官方如此设计是希望对上层开发者无感知。这两个方法的使用就说这么多，如果你对其内部实现原理感兴趣就请继续阅读下去～</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="foldin-与-foldout-实现原理">foldIn() 与 foldOut() 实现原理<a class="hash-link" href="#foldin-与-foldout-实现原理" title="Direct link to heading">​</a></h3><p>为探索原理，老规矩我们就需要进入源码一探究竟了。我们上来要做的就是找到 <strong>foldIn()</strong> 方法的实现。通过前面的例子我们可以得知，当 Modifier 链的长度大于等于 2 时，返回的 Modifier 实际上是一个 CombinedModifier 实例。那么我们就看看 ConbinedModifier 里面是怎么重写的 <strong>foldIn()</strong> 方法。</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">class CombinedModifier(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private val outer: Modifier,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private val inner: Modifier</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">) : Modifier {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    override fun &lt;R&gt; foldIn(initial: R, operation: (R, Modifier.Element) -&gt; R): R =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        inner.foldIn(outer.foldIn(initial, operation), operation) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>可以看到第一个参数传入的是 outer.foldIn(initial. operation) 的返回值，经过一路递归向上即可到达最顶部的outer Modifier。值得注意的是，我们设置的初始值也跟随outer一路透传上去了。</p><div align="center"><img src="/assets/images/demo10-1497f4633c8e333d1cd7abc81a937093.png" width="50%" height="50%"></div><p>根据 Modifier 链的数据结构，我们很容易发现最顶部的outer Modifier一定是个 Modifier.Element，此时我们就要看看 Modifier.Element 是怎么重写的 <strong>foldIn()</strong> 方法了。通过源码我们看到直接调用了我们传入的lambda，并将 lambda 返回值作为 <strong>foldIn()</strong> 方法的返回值返回。</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">interface Element : Modifier {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    override fun &lt;R&gt; foldIn(initial: R, operation: (R, Element) -&gt; R): R =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        operation(initial, this)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>接下来，我们就退到了上一层 CombinedModifier，接下里我们再看看他是怎么做的。紧接着调用了 inner.foldIn()</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">class CombinedModifier(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private val outer: Modifier,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private val inner: Modifier</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">) : Modifier {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    override fun &lt;R&gt; foldIn(initial: R, operation: (R, Modifier.Element) -&gt; R): R =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        inner.foldIn(outer.foldIn(initial, operation), operation) </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>我们不妨看看当前场景下的图示。</p><div align="center"><img src="/assets/images/demo11-a4d862285e4d863e5cfff1a8d91a366b.png" width="50%" height="50%"></div><p>整个流程就非常清晰了，直到最后一个 inner Modifier 被遍历后便会将 lambda 结果返回给开发者。通过流程的解读，我们可知之所以我们的便利过程没有 CombindedModifier，是因为 CombinedModifier 虽重写了 <strong>foldIn()方法</strong>，但并没有调用我们传入的lambda。而只有所有 Modifier.Element 才会调用我们传入的 lambda。</p><p>理解了 <strong>foldIn() 方法</strong> 的实现原理，<strong>foldOut() 方法</strong> 的实现原理是完全相同的，只是遍历顺序是完全相反的，这里就不多加赘述了。</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="foldin-与-foldout-的应用">foldIn() 与 foldOut() 的应用<a class="hash-link" href="#foldin-与-foldout-的应用" title="Direct link to heading">​</a></h3><p>弄懂了实现原理后，我们就来看看该怎么用。Compose 源码中将我们所创建的 Modifier 传入 Layout 的过程就是对 <strong>foldIn() 方法</strong> 与 <strong>foldOut() 方法</strong>  的一次最佳实践。</p><p>我们知道 Compose 组件都是基于 Layout 这个基础组件实现的，所以我们来看看我们创建的  Modifier 在其中是如何进行传递的。可以发现我们的 modifier 传入了一个名为 <code>materializerOf</code> 方法</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">@Composable inline fun Layout(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    content: @Composable () -&gt; Unit,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    modifier: Modifier = Modifier,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    measurePolicy: MeasurePolicy</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ReusableComposeNode&lt;ComposeUiNode, Applier&lt;Any&gt;&gt;(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        factory = ...,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        update = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        skippableUpdate = materializerOf(modifier), // 重点</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        content = ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>继续跟进，我们会走进 Composer.materialize()。可以发现源码中使用了 <strong>fouldIn() 方法</strong>。 在其中我们看到了对于 ComposedModifier 的特殊判断。还记得 <code>composed()</code> 返回的 ComposedModifier 嘛。根据前文我们可知，我们正常得到的 Modifier 链其中是可能包含 ComposedModifier的，而这里想做的是将 Modifier 链中的所有 ComposedModifier 摊平，让其 factory 内部产生的 Modifier 也能加入到 Modifier 链中。</p><p>这里使用了 <strong>fouldIn() 方法</strong> 进行了正向遍历，传入的初始值为 Modifier。当遍历到 ComposedModifier 时，则使用其内部的 factory 来生产 Modifier，值得注意的是此时生成的 Modifier 可能也是 Modifier 链或单个 Modifier。生成的 Modifier 其中也可能会包含 ComposedModifier，所以这里就进行了递归处理。最终目标就是所得到的 Modifier 链中是不包含 ComposedModifier 结点的，即完全摊开的 Modifier 链。</p><div class="codeBlockContainer_I0IT language-kotlin theme-code-block"><div class="codeBlockContent_wNvx kotlin"><pre tabindex="0" class="prism-code language-kotlin codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">fun Composer.materialize(modifier: Modifier): Modifier {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    val result = modifier.foldIn&lt;Modifier&gt;(Modifier) { acc, element -&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        acc.then(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (element is ComposedModifier) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                @kotlin.Suppress(&quot;UNCHECKED_CAST&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                val factory = element.factory as Modifier.(Composer, Int) -&gt; Modifier</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                val composedMod = factory(Modifier, this, 0) // 生产 Modifier</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                materialize(composedMod) // 生成出的 Modifier 可能也包含 ComposedModifier，递归处理</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } else element</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return result</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>Modifier 链后续还会使用 <strong>foldOut方法</strong> 进行遍历从而生成 LayoutNodeWrapper 链，了解 Modifier 链的本质将有助于理解 Jetpack Compose 源码中测量布局流程，感兴趣小伙伴可以拓展阅读文章 <a href="https://juejin.cn/post/6981805443219718151" target="_blank" rel="noopener noreferrer">《Jetpack Compose 测量流程源码分析》</a></p><h2 class="anchor anchorWithStickyNavbar_mojV" id="总结">总结<a class="hash-link" href="#总结" title="Direct link to heading">​</a></h2><p>这篇文章的目的就是带领大家对 Modifier 链背后的数据结构与执行逻辑进行分析，使大家对于 Modifier 链的本质有一个清晰的认识。弄清楚了 Modifier 链的本质以后，以后使用 Modifier 出现问题时就容易进行排查了。总之对本质了解的越多，使用起来就越顺手！</p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/compose-museum/jetpack-compose-book/tree/master/docs/principle/modifierStructure.mdx" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_dcUD" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_foO9"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/docs/principle/gapBuffer"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">Compose 运行原理与 GapBuffer</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/docs/principle/composeAnnotation"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Compose 注解到底做了什么？</div></a></div></nav></div></div><div class="col col--3"><div class="tableOfContents_cNA8 thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#modifier-接口" class="table-of-contents__link toc-highlight">Modifier 接口</a></li><li><a href="#modifier-链的构建过程" class="table-of-contents__link toc-highlight">Modifier 链的构建过程</a><ul><li><a href="#then" class="table-of-contents__link toc-highlight">then()</a></li><li><a href="#composed" class="table-of-contents__link toc-highlight">composed()</a></li></ul></li><li><a href="#modifier-链的遍历" class="table-of-contents__link toc-highlight">Modifier 链的遍历</a><ul><li><a href="#foldin-与-foldout-用法" class="table-of-contents__link toc-highlight">foldIn() 与 foldOut() 用法</a></li><li><a href="#foldin-与-foldout-实现原理" class="table-of-contents__link toc-highlight">foldIn() 与 foldOut() 实现原理</a></li><li><a href="#foldin-与-foldout-的应用" class="table-of-contents__link toc-highlight">foldIn() 与 foldOut() 的应用</a></li></ul></li><li><a href="#总结" class="table-of-contents__link toc-highlight">总结</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">社区</div><ul class="footer__items"><li class="footer__item"><a href="https://github.com/compose-museum" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Github<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2022 Jetpack Compose 博物馆, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.3ebcbd4b.js"></script>
<script src="/assets/js/main.50fd7d2b.js"></script>
</body>
</html>